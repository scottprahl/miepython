{"version":3,"file":"7311.12fb7de.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/licenses.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/pluginmanager.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/apputils/lib/translation.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Licenses } from '@jupyterlab/apputils';\nimport { URLExt, PageConfig } from '@jupyterlab/coreutils';\n/**\n * The well-known name of the file. Can actually be configured by alternate\n * implementations, but the default is probably good enough for \"best-effort.\"\n */\nexport const THIRD_PARTY_LICENSES = 'third-party-licenses.json';\n/**\n * An empty bundle.\n */\nconst EMPTY_BUNDLE = Object.freeze({ packages: [] });\n/**\n * A JupyterLite implementation of the jupyterlab_server licenses route\n */\nexport class LiteLicensesClient extends Licenses.LicensesClient {\n    /**\n     * A GET handler for the licenses\n     */\n    async getBundles() {\n        return {\n            bundles: {\n                ...(await this._getFederated()),\n                [this.appName]: await this._getAppLicenses(),\n            },\n        };\n    }\n    /**\n     * Download the licenses in the requested format.\n     */\n    async download(options) {\n        const link = document.createElement('a');\n        link.href = await this._getDownloadLink(options);\n        const extension = options.format === 'markdown' ? 'md' : options.format;\n        link.download = `jupyterlite-licenses.${extension}`;\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    /**\n     * Get the app name (or default).\n     */\n    get appName() {\n        return PageConfig.getOption('appName') || 'JupyterLite';\n    }\n    /**\n     * Get the well-known URL of the app licenses.\n     */\n    get appLicensesUrl() {\n        return URLExt.join(PageConfig.getBaseUrl(), 'build', THIRD_PARTY_LICENSES);\n    }\n    /**\n     * Get the lab extension base url.\n     */\n    get labExtensionsUrl() {\n        return PageConfig.getOption('fullLabextensionsUrl');\n    }\n    /**\n     * Get the download link for the requested format\n     */\n    async _getDownloadLink(options) {\n        const bundles = await this.getBundles();\n        let formattedData;\n        let mime;\n        // Format the data based on the requested format\n        switch (options.format) {\n            case 'json':\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n                break;\n            case 'markdown':\n                formattedData = this._formatAsMarkdown(bundles);\n                mime = 'text/markdown';\n                break;\n            case 'csv':\n                formattedData = this._formatAsCSV(bundles);\n                mime = 'text/csv';\n                break;\n            default:\n                // Fallback to JSON\n                formattedData = JSON.stringify(bundles, null, 2);\n                mime = 'application/json';\n        }\n        // Create a blob with the appropriate MIME type\n        const blob = new Blob([formattedData], { type: mime });\n        // Generate a URL for the blob\n        return URL.createObjectURL(blob);\n    }\n    /**\n     * Format license data as Markdown\n     */\n    _formatAsMarkdown(data) {\n        let md = '# Third-Party Licenses\\n\\n';\n        // Process each bundle\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            md += `## ${bundleName}\\n\\n`;\n            // Process packages in the bundle\n            for (const pkg of bundle.packages) {\n                md += `### ${pkg.name}${pkg.versionInfo ? ` ${pkg.versionInfo}` : ''}\\n\\n`;\n                if (pkg.licenseId) {\n                    md += `**License ID:** ${pkg.licenseId}\\n\\n`;\n                }\n                if (pkg.extractedText) {\n                    md += `\\`\\`\\`\\n${pkg.extractedText}\\n\\`\\`\\`\\n\\n`;\n                }\n            }\n        }\n        return md;\n    }\n    /**\n     * Format license data as CSV\n     */\n    _formatAsCSV(data) {\n        // CSV header\n        const headers = ['Bundle', 'Package', 'Version', 'License ID', 'License Text'];\n        let csv = `${headers.join(',')}\\n`;\n        // Process each bundle and package\n        for (const [bundleName, bundle] of Object.entries(data.bundles)) {\n            for (const pkg of bundle.packages) {\n                const row = [\n                    this._escapeCSVField(bundleName),\n                    this._escapeCSVField(pkg.name),\n                    this._escapeCSVField(pkg.versionInfo || ''),\n                    this._escapeCSVField(pkg.licenseId || ''),\n                    this._escapeCSVField(pkg.extractedText || ''),\n                ];\n                csv += `${row.join(',')}\\n`;\n            }\n        }\n        return csv;\n    }\n    /**\n     * Escape a field for CSV output\n     */\n    _escapeCSVField(field) {\n        // If the field contains commas, quotes, or newlines, wrap it in quotes and escape any quotes\n        if (field && (field.includes(',') || field.includes('\"') || field.includes('\\n'))) {\n            return `\"${field.replace(/\"/g, '\"\"')}\"`;\n        }\n        return field;\n    }\n    /**\n     * Resolve the licenses for the app distribution itself, or the empty bundle.\n     */\n    async _getAppLicenses() {\n        let bundle = EMPTY_BUNDLE;\n        try {\n            const response = await fetch(this.appLicensesUrl);\n            bundle = response.json();\n        }\n        catch (err) {\n            console.warn('Could not resolve licenses for', this.appName);\n        }\n        return bundle;\n    }\n    /**\n     * Resolve the licenses for all federated extensions.\n     */\n    async _getFederated() {\n        const bundles = {};\n        let federated;\n        try {\n            federated = JSON.parse(PageConfig.getOption('federated_extensions'));\n        }\n        catch {\n            return bundles;\n        }\n        const promises = [];\n        for (const ext of federated) {\n            promises.push(this._getOneFederated(ext, bundles));\n        }\n        try {\n            await Promise.all(promises);\n        }\n        catch (err) {\n            console.warn('Error resolving licenses', err);\n        }\n        return bundles;\n    }\n    /**\n     * Update the bundles with the extension's licenses, or the empty bundle.\n     */\n    async _getOneFederated(ext, bundles) {\n        try {\n            const url = URLExt.join(this.labExtensionsUrl, ext.name, 'static', THIRD_PARTY_LICENSES);\n            const response = await fetch(url);\n            bundles[ext.name] = await response.json();\n        }\n        catch {\n            console.warn('Could not resolve licenses for', ext);\n            bundles[ext.name] = EMPTY_BUNDLE;\n        }\n    }\n}\n//# sourceMappingURL=licenses.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PluginListModel } from '@jupyterlab/pluginmanager';\n/**\n * Custom PluginModel for use in JupyterLite\n */\nexport class LitePluginListModel extends PluginListModel {\n    /**\n     * Create a new PluginListModel.\n     */\n    constructor(options) {\n        super(options);\n        this._availablePlugins = options.pluginData.availablePlugins.map((plugin) => {\n            let tokenLabel = plugin.provides ? plugin.provides.name.split(':')[1] : undefined;\n            if (plugin.provides && !tokenLabel) {\n                tokenLabel = plugin.provides.name;\n            }\n            return {\n                ...plugin,\n                tokenLabel,\n                // keep all plugins locked and enabled for now until there is\n                // a way to enable/disable plugins in JupyterLite\n                locked: true,\n                enabled: true,\n            };\n        });\n    }\n    get available() {\n        return this._availablePlugins;\n    }\n    async refresh() {\n        // no-op\n    }\n    async enable(entry) {\n        // no-op\n    }\n    async disable(entry) {\n        // no-op\n    }\n}\n//# sourceMappingURL=pluginmanager.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A fake locale to retrieve all the language packs.\n */\nconst ALL = 'all';\n/**\n * A class to fetch translation bundles.\n */\nexport class LiteTranslatorConnector extends DataConnector {\n    constructor() {\n        super(...arguments);\n        this._prevLocale = '';\n    }\n    async fetch(opts) {\n        var _a;\n        const language = (_a = opts === null || opts === void 0 ? void 0 : opts.language) !== null && _a !== void 0 ? _a : '';\n        // normalize the requested locale\n        let locale = language;\n        if (language === 'default') {\n            locale = 'en';\n        }\n        else if (language === '') {\n            locale = ALL;\n        }\n        const apiURL = URLExt.join(PageConfig.getBaseUrl(), `api/translations/${locale}.json`);\n        try {\n            const response = await fetch(apiURL);\n            const json = JSON.parse(await response.text());\n            if (this._prevLocale !== ALL && locale === ALL) {\n                // TODO: fix this logic upstream?\n                // the upstream translation plugin relies on the comparison between\n                // the display name and the native name to enable or disable the commands:\n                // https://github.com/jupyterlab/jupyterlab/blob/befa831ffef36321b87f352a48fbe2439df6c872/packages/translation-extension/src/index.ts#L117\n                const prev = this._prevLocale;\n                json.data[prev].displayName = json.data[prev].nativeName;\n                if (prev !== 'en') {\n                    json.data['en'].displayName = `${json.data['en'].nativeName} (default)`;\n                }\n            }\n            this._prevLocale = locale;\n            return json;\n        }\n        catch (e) {\n            if (locale) {\n                return {\n                    data: {},\n                    message: `Language pack '${locale}' not installed!`,\n                };\n            }\n            return {\n                data: {\n                    en: { displayName: 'English', nativeName: 'English' },\n                },\n                message: '',\n            };\n        }\n    }\n}\n//# sourceMappingURL=translation.js.map"],"names":["THIRD_PARTY_LICENSES","EMPTY_BUNDLE","Object","freeze","packages","LiteLicensesClient","Licenses","LicensesClient","getBundles","bundles","this","_getFederated","appName","_getAppLicenses","download","options","link","document","createElement","href","_getDownloadLink","extension","format","body","appendChild","click","removeChild","PageConfig","getOption","appLicensesUrl","URLExt","join","getBaseUrl","labExtensionsUrl","formattedData","mime","JSON","stringify","_formatAsMarkdown","_formatAsCSV","blob","Blob","type","URL","createObjectURL","data","md","bundleName","bundle","entries","pkg","name","versionInfo","licenseId","extractedText","csv","_escapeCSVField","field","includes","replace","fetch","json","err","console","warn","federated","parse","promises","ext","push","_getOneFederated","Promise","all","url","response","LitePluginListModel","PluginListModel","constructor","super","_availablePlugins","pluginData","availablePlugins","map","plugin","tokenLabel","provides","split","undefined","locked","enabled","available","refresh","enable","entry","disable","ALL","LiteTranslatorConnector","DataConnector","arguments","_prevLocale","opts","_a","language","locale","apiURL","text","prev","displayName","nativeName","e","message","en"],"sourceRoot":""}