{"version":3,"file":"100.fc995bd.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/base.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernelspecs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernelspecclient.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/async-mutex/index.mjs","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/client.js"],"sourcesContent":["import { KernelMessage } from '@jupyterlab/services';\nimport { Signal } from '@lumino/signaling';\n/**\n * A base kernel class handling basic kernel messaging.\n */\nexport class BaseKernel {\n    /**\n     * Construct a new BaseKernel.\n     *\n     * @param options The instantiation options for a BaseKernel.\n     */\n    constructor(options) {\n        this._history = [];\n        this._executionCount = 0;\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._parentHeader = undefined;\n        this._parent = undefined;\n        const { id, name, location, sendMessage } = options;\n        this._id = id;\n        this._name = name;\n        this._location = location;\n        this._sendMessage = sendMessage;\n    }\n    /**\n     * A promise that is fulfilled when the kernel is ready.\n     */\n    get ready() {\n        return Promise.resolve();\n    }\n    /**\n     * Return whether the kernel is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the kernel is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Get the kernel id\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the name of the kernel\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The location in the virtual filesystem from which the kernel was started.\n     */\n    get location() {\n        return this._location;\n    }\n    /**\n     * The current execution count\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    /**\n     * Get the last parent header\n     */\n    get parentHeader() {\n        return this._parentHeader;\n    }\n    /**\n     * Get the last parent message (mimic ipykernel's get_parent)\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Dispose the kernel.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n    }\n    /**\n     * Handle an incoming message from the client.\n     *\n     * @param msg The message to handle\n     */\n    async handleMessage(msg) {\n        this._busy(msg);\n        this._parent = msg;\n        const msgType = msg.header.msg_type;\n        switch (msgType) {\n            case 'kernel_info_request':\n                await this._kernelInfo(msg);\n                break;\n            case 'execute_request':\n                await this._execute(msg);\n                break;\n            case 'input_reply':\n                this.inputReply(msg.content);\n                break;\n            case 'inspect_request':\n                await this._inspect(msg);\n                break;\n            case 'is_complete_request':\n                await this._isCompleteRequest(msg);\n                break;\n            case 'complete_request':\n                await this._complete(msg);\n                break;\n            case 'history_request':\n                await this._historyRequest(msg);\n                break;\n            case 'comm_open':\n                await this.commOpen(msg);\n                break;\n            case 'comm_msg':\n                await this.commMsg(msg);\n                break;\n            case 'comm_close':\n                await this.commClose(msg);\n                break;\n            default:\n                break;\n        }\n        this._idle(msg);\n    }\n    /**\n     * Stream an event from the kernel\n     *\n     * @param parentHeader The parent header.\n     * @param content The stream content.\n     */\n    stream(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'stream',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The display_data content.\n     */\n    displayData(content, parentHeader = undefined) {\n        var _a, _b;\n        // Make sure metadata is always set\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        content.metadata = (_a = content.metadata) !== null && _a !== void 0 ? _a : {};\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'display_data',\n            // TODO: better handle this\n            session: (_b = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _b !== void 0 ? _b : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `input_request` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The input_request content.\n     */\n    inputRequest(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'stdin',\n            msgType: 'input_request',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_result` message.\n     *\n     * @param parentHeader The parent header.\n     * @param content The execute result content.\n     */\n    publishExecuteResult(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'execute_result',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `error` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The error content.\n     */\n    publishExecuteError(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'error',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `update_display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The update_display_data content.\n     */\n    updateDisplayData(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'update_display_data',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `clear_output` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The clear_output content.\n     */\n    clearOutput(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'clear_output',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `comm` message to the client.\n     *\n     * @param .\n     */\n    handleComm(type, content, metadata, buffers, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: type,\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n            metadata,\n            buffers,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an 'idle' status message.\n     *\n     * @param parent The parent message\n     */\n    _idle(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'idle',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a 'busy' status message.\n     *\n     * @param parent The parent message.\n     */\n    _busy(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'busy',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a kernel_info_request message\n     *\n     * @param parent The parent message.\n     */\n    async _kernelInfo(parent) {\n        const content = await this.kernelInfoRequest();\n        const message = KernelMessage.createMessage({\n            msgType: 'kernel_info_reply',\n            channel: 'shell',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a `history_request` message\n     *\n     * @param msg The parent message.\n     */\n    async _historyRequest(msg) {\n        const historyMsg = msg;\n        const message = KernelMessage.createMessage({\n            msgType: 'history_reply',\n            channel: 'shell',\n            parentHeader: historyMsg.header,\n            session: msg.header.session,\n            content: {\n                status: 'ok',\n                history: this._history,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_input` message.\n     *\n     * @param msg The parent message.\n     */\n    _executeInput(msg) {\n        const parent = msg;\n        const code = parent.content.code;\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_input',\n            parentHeader: parent.header,\n            channel: 'iopub',\n            session: msg.header.session,\n            content: {\n                code,\n                execution_count: this._executionCount,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an execute_request message.\n     *\n     * @param msg The parent message.\n     */\n    async _execute(msg) {\n        const executeMsg = msg;\n        const content = executeMsg.content;\n        if (content.store_history) {\n            this._executionCount++;\n        }\n        // TODO: handle differently\n        this._parentHeader = executeMsg.header;\n        this._executeInput(executeMsg);\n        if (content.store_history) {\n            this._history.push([0, 0, content.code]);\n        }\n        const reply = await this.executeRequest(executeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_reply',\n            channel: 'shell',\n            parentHeader: executeMsg.header,\n            session: msg.header.session,\n            content: reply,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _complete(msg) {\n        const completeMsg = msg;\n        const content = await this.completeRequest(completeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'complete_reply',\n            parentHeader: completeMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an inspect_request message\n     *\n     * @param msg The parent message.\n     */\n    async _inspect(msg) {\n        const inspectMsg = msg;\n        const content = await this.inspectRequest(inspectMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'inspect_reply',\n            parentHeader: inspectMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an is_complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _isCompleteRequest(msg) {\n        const isCompleteMsg = msg;\n        const content = await this.isCompleteRequest(isCompleteMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'is_complete_reply',\n            parentHeader: isCompleteMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n}\n//# sourceMappingURL=base.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The kernel name of last resort.\n */\nexport const FALLBACK_KERNEL = 'javascript';\n/**\n * The token for the kernel client.\n */\nexport const IKernelClient = new Token('@jupyterlite/kernel:IKernelClient');\n/**\n * The token for the kernel spec client.\n */\nexport const IKernelSpecClient = new Token('@jupyterlite/kernel:IKernelSpecClient');\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token('@jupyterlite/kernel:IKernelSpecs');\n//# sourceMappingURL=tokens.js.map","import { PageConfig } from '@jupyterlab/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * A class to register in-browser kernel specs.\n */\nexport class KernelSpecs {\n    constructor() {\n        this._specs = new Map();\n        this._factories = new Map();\n        this._changed = new Signal(this);\n    }\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: this.defaultKernelName,\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the default kernel name.\n     */\n    get defaultKernelName() {\n        let defaultKernelName = PageConfig.getOption('defaultKernelName');\n        if (!defaultKernelName && this._specs.size) {\n            const keys = Array.from(this._specs.keys());\n            keys.sort();\n            defaultKernelName = keys[0];\n        }\n        return defaultKernelName || FALLBACK_KERNEL;\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Signal emitted when the specs change.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n        // notify a new spec has been added\n        this._changed.emit(this.specs);\n    }\n}\n//# sourceMappingURL=kernelspecs.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Placeholder for the kernel specs.\n */\nconst EMPTY_KERNELSPECS = {\n    default: '',\n    kernelspecs: {},\n};\n/**\n * An in-browser client for the kernel spec API.\n */\nexport class LiteKernelSpecClient {\n    /**\n     * Construct a new kernel spec client.\n     */\n    constructor(options) {\n        var _a;\n        this._kernelspecs = options.kernelSpecs;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n    }\n    /**\n     * The server settings used by the client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Get the kernel specs.\n     */\n    async get() {\n        var _a;\n        return Promise.resolve((_a = this._kernelspecs.specs) !== null && _a !== void 0 ? _a : EMPTY_KERNELSPECS);\n    }\n}\n//# sourceMappingURL=kernelspecclient.js.map","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { ObservableMap } from '@jupyterlab/observables';\nimport { KernelAPI, ServerConnection, } from '@jupyterlab/services';\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\nimport { supportedKernelWebSocketProtocols } from '@jupyterlab/services/lib/kernel/messages';\nimport { PromiseDelegate, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { Mutex } from 'async-mutex';\nimport { Server as WebSocketServer } from 'mock-socket';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * Use the default kernel wire protocol.\n */\nconst KERNEL_WEBSOCKET_PROTOCOL = supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg;\n/**\n * A class to handle requests to /api/kernels\n */\nexport class LiteKernelClient {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        var _a;\n        this._kernels = new ObservableMap();\n        this._clients = new ObservableMap();\n        this._kernelClients = new ObservableMap();\n        this._changed = new Signal(this);\n        this._kernelSends = new ObservableMap();\n        const { kernelSpecs } = options;\n        this._kernelspecs = kernelSpecs;\n        this._serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : ServerConnection.makeSettings();\n        // Forward the changed signal from _kernels\n        this._kernels.changed.connect((_, args) => {\n            this._changed.emit(args);\n        });\n    }\n    /**\n     * The server settings for the kernel client.\n     */\n    get serverSettings() {\n        return this._serverSettings;\n    }\n    /**\n     * Signal emitted when the kernels map changes\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name, location } = options;\n        const kernelName = name !== null && name !== void 0 ? name : FALLBACK_KERNEL;\n        const factory = this._kernelspecs.factories.get(kernelName);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            throw Error(`No factory for kernel ${kernelName}`);\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            var _a;\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.add(clientId);\n            const processMsg = async (msg) => {\n                try {\n                    await mutex.runExclusive(async () => {\n                        await kernel.ready;\n                        await kernel.handleMessage(msg);\n                    });\n                }\n                catch (error) {\n                    if (error instanceof Error &&\n                        error.message.includes('request for lock canceled')) {\n                        // expected to throw when mutex.cancel() is called below\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else if (typeof message === 'string') {\n                    const encoder = new TextEncoder();\n                    const encodedData = encoder.encode(message);\n                    msg = deserialize(encodedData.buffer, KERNEL_WEBSOCKET_PROTOCOL);\n                }\n                else {\n                    return;\n                }\n                if (msg.header.msg_type === 'input_reply') {\n                    if (this._stdinPromise !== undefined) {\n                        // Stdin handled by Service Worker.\n                        this._stdinPromise.resolve(msg);\n                    }\n                    else {\n                        // Stdin handled by SharedArrayBuffer which is like conventional message\n                        // passing to kernel except we cannot use processMsg as the mutex is\n                        // already held.\n                        void kernel.handleMessage(msg);\n                    }\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                var _a;\n                this._clients.delete(clientId);\n                (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id !== null && id !== void 0 ? id : UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = URLExt.join(LiteKernelClient.WS_BASE_URL, KernelAPI.KERNEL_SERVICE_URL, encodeURIComponent(kernelId), 'channels');\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.channel === 'stdin' ? msg.parent_header.session : msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg, KERNEL_WEBSOCKET_PROTOCOL);\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients === null || clients === void 0 ? void 0 : clients.forEach((id) => {\n                    var _a;\n                    (_a = this._clients.get(id)) === null || _a === void 0 ? void 0 : _a.send(message);\n                });\n                return;\n            }\n            // cancel the execution of other cells if there is an execute error\n            // to match the JupyterLab behavior\n            if (msg.header.msg_type === 'execute_reply') {\n                const executeReplyMsg = msg;\n                if (executeReplyMsg.content.status === 'error') {\n                    mutex.cancel();\n                }\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name: kernelName,\n            location: location !== null && location !== void 0 ? location : '',\n        });\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        this._kernelSends.set(kernelId, sendMessage);\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl, {\n            mock: false,\n            selectProtocol: () => KERNEL_WEBSOCKET_PROTOCOL,\n        });\n        wsServer.on('connection', (socket) => {\n            var _a;\n            const url = new URL(socket.url);\n            const clientId = (_a = url.searchParams.get('session_id')) !== null && _a !== void 0 ? _a : '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach((clientId) => {\n                var _a;\n                const socket = this._clients.get(clientId);\n                if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n            this._kernelSends.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name, location } = kernel;\n        kernel.dispose();\n        await this.startNew({ id, name, location });\n    }\n    /**\n     * Interrupt a kernel.\n     */\n    async interrupt(kernelId) {\n        // no-op\n    }\n    /**\n     * List the running kernels.\n     */\n    async listRunning() {\n        return [...this._kernels.values()].map((kernel) => ({\n            id: kernel.id,\n            name: kernel.name,\n        }));\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        var _a;\n        (_a = this._kernels.delete(id)) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._kernelClients.delete(id);\n        this._kernelSends.delete(id);\n    }\n    /**\n     * Shut down all kernels.\n     */\n    async shutdownAll() {\n        this._kernels.keys().forEach((id) => {\n            this.shutdown(id);\n        });\n    }\n    /**\n     * Get a kernel by id\n     */\n    async getModel(id) {\n        return this._kernels.get(id);\n    }\n    /**\n     * Handle stdin request received from Service Worker.\n     */\n    async handleStdin(inputRequest) {\n        this._stdinPromise = new PromiseDelegate();\n        const clientId = inputRequest.parent_header.session;\n        const kernelId = this._getClientKernel(clientId);\n        if (kernelId !== undefined) {\n            const sendMessage = this._kernelSends.get(kernelId);\n            if (sendMessage !== undefined) {\n                sendMessage(inputRequest);\n            }\n        }\n        // Promise is resolved by input reply message.\n        return this._stdinPromise.promise;\n    }\n    /**\n     * Get a kernel id corresponding to a client id.\n     */\n    _getClientKernel(clientId) {\n        // Walk the _kernelClients to find a match.\n        return this._kernelClients\n            .keys()\n            .find((kernelId) => this._kernelClients.get(kernelId).has(clientId));\n    }\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (LiteKernelClient) {\n    /**\n     * The base url for the Kernels manager\n     */\n    LiteKernelClient.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(LiteKernelClient || (LiteKernelClient = {}));\n//# sourceMappingURL=client.js.map"],"names":["BaseKernel","constructor","options","this","_history","_executionCount","_isDisposed","_disposed","Signal","_parentHeader","undefined","_parent","id","name","location","sendMessage","_id","_name","_location","_sendMessage","ready","Promise","resolve","isDisposed","disposed","executionCount","parentHeader","parent","dispose","emit","handleMessage","msg","_busy","header","msg_type","_kernelInfo","_execute","inputReply","content","_inspect","_isCompleteRequest","_complete","_historyRequest","commOpen","commMsg","commClose","_idle","stream","_a","parentHeaderValue","message","KernelMessage","createMessage","channel","msgType","session","displayData","_b","metadata","inputRequest","publishExecuteResult","publishExecuteError","updateDisplayData","clearOutput","handleComm","type","buffers","execution_state","kernelInfoRequest","historyMsg","status","history","_executeInput","code","execution_count","executeMsg","store_history","push","reply","executeRequest","completeMsg","completeRequest","inspectMsg","inspectRequest","isCompleteMsg","isCompleteRequest","FALLBACK_KERNEL","IKernelClient","Token","IKernelSpecClient","IKernelSpecs","KernelSpecs","_specs","Map","_factories","_changed","specs","size","default","defaultKernelName","kernelspecs","Object","fromEntries","PageConfig","getOption","keys","Array","from","sort","factories","changed","register","spec","create","set","EMPTY_KERNELSPECS","LiteKernelSpecClient","_kernelspecs","kernelSpecs","_serverSettings","serverSettings","ServerConnection","makeSettings","get","Error","E_CANCELED","__awaiter$2","thisArg","_arguments","P","generator","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Semaphore","_maxConcurrency","_cancelError","_queue","_waiters","_value","acquire","locked","isLocked","ticketPromise","_dispatch","runExclusive","callback","release","waitForUnlock","_currentReleaser","releaser","cancel","forEach","ticket","nextTicket","shift","released","_resolveWaiters","waiter","Mutex","cancelError","_semaphore","KERNEL_WEBSOCKET_PROTOCOL","supportedKernelWebSocketProtocols","v1KernelWebsocketJupyterOrg","LiteKernelClient","_kernels","ObservableMap","_clients","_kernelClients","_kernelSends","connect","_","args","startNew","kernelName","factory","mutex","hook","kernelId","clientId","socket","kernel","add","on","async","ArrayBuffer","Uint8Array","buffer","deserialize","encodedData","TextEncoder","encode","_stdinPromise","error","includes","processMsg","removeClient","delete","onclose","UUID","uuid4","kernelUrl","URLExt","join","WS_BASE_URL","KernelAPI","KERNEL_SERVICE_URL","encodeURIComponent","runningKernel","parent_header","console","warn","serialize","send","clients","Set","wsServer","mock","selectProtocol","URL","url","searchParams","readyState","WebSocket","CLOSED","close","restart","interrupt","listRunning","values","map","shutdown","shutdownAll","getModel","handleStdin","PromiseDelegate","_getClientKernel","promise","find","has","getBaseUrl","replace"],"sourceRoot":""}