{"version":3,"file":"306.d4bc205.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/generator/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\nimport { LRParser, LocalTokenGroup } from '@lezer/lr';\n\nclass Node {\n    constructor(start) {\n        this.start = start;\n    }\n}\nclass GrammarDeclaration extends Node {\n    constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {\n        super(start);\n        this.rules = rules;\n        this.topRules = topRules;\n        this.tokens = tokens;\n        this.localTokens = localTokens;\n        this.context = context;\n        this.externalTokens = externalTokens;\n        this.externalSpecializers = externalSpecializers;\n        this.externalPropSources = externalPropSources;\n        this.precedences = precedences;\n        this.mainSkip = mainSkip;\n        this.scopedSkip = scopedSkip;\n        this.dialects = dialects;\n        this.externalProps = externalProps;\n        this.autoDelim = autoDelim;\n    }\n    toString() { return Object.values(this.rules).join(\"\\n\"); }\n}\nclass RuleDeclaration extends Node {\n    constructor(start, id, props, params, expr) {\n        super(start);\n        this.id = id;\n        this.props = props;\n        this.params = params;\n        this.expr = expr;\n    }\n    toString() {\n        return this.id.name + (this.params.length ? `<${this.params.join()}>` : \"\") + \" -> \" + this.expr;\n    }\n}\nclass PrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenPrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenConflictDeclaration extends Node {\n    constructor(start, a, b) {\n        super(start);\n        this.a = a;\n        this.b = b;\n    }\n}\nclass TokenDeclaration extends Node {\n    constructor(start, precedences, conflicts, rules, literals) {\n        super(start);\n        this.precedences = precedences;\n        this.conflicts = conflicts;\n        this.rules = rules;\n        this.literals = literals;\n    }\n}\nclass LocalTokenDeclaration extends Node {\n    constructor(start, precedences, rules, fallback) {\n        super(start);\n        this.precedences = precedences;\n        this.rules = rules;\n        this.fallback = fallback;\n    }\n}\nclass LiteralDeclaration extends Node {\n    constructor(start, literal, props) {\n        super(start);\n        this.literal = literal;\n        this.props = props;\n    }\n}\nclass ContextDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalTokenDeclaration extends Node {\n    constructor(start, id, source, tokens) {\n        super(start);\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalSpecializeDeclaration extends Node {\n    constructor(start, type, token, id, source, tokens) {\n        super(start);\n        this.type = type;\n        this.token = token;\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalPropSourceDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalPropDeclaration extends Node {\n    constructor(start, id, externalID, source) {\n        super(start);\n        this.id = id;\n        this.externalID = externalID;\n        this.source = source;\n    }\n}\nclass Identifier extends Node {\n    constructor(start, name) {\n        super(start);\n        this.name = name;\n    }\n    toString() { return this.name; }\n}\nclass Expression extends Node {\n    walk(f) { return f(this); }\n    eq(_other) { return false; }\n}\nExpression.prototype.prec = 10;\nclass NameExpression extends Expression {\n    constructor(start, id, args) {\n        super(start);\n        this.id = id;\n        this.args = args;\n    }\n    toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : \"\"); }\n    eq(other) {\n        return this.id.name == other.id.name && exprsEq(this.args, other.args);\n    }\n    walk(f) {\n        let args = walkExprs(this.args, f);\n        return f(args == this.args ? this : new NameExpression(this.start, this.id, args));\n    }\n}\nclass SpecializeExpression extends Expression {\n    constructor(start, type, props, token, content) {\n        super(start);\n        this.type = type;\n        this.props = props;\n        this.token = token;\n        this.content = content;\n    }\n    toString() { return `@${this.type}[${this.props.join(\",\")}]<${this.token}, ${this.content}>`; }\n    eq(other) {\n        return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&\n            exprEq(this.content, other.content);\n    }\n    walk(f) {\n        let token = this.token.walk(f), content = this.content.walk(f);\n        return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));\n    }\n}\nclass InlineRuleExpression extends Expression {\n    constructor(start, rule) {\n        super(start);\n        this.rule = rule;\n    }\n    toString() {\n        let rule = this.rule;\n        return `${rule.id}${rule.props.length ? `[${rule.props.join(\",\")}]` : \"\"} { ${rule.expr} }`;\n    }\n    eq(other) {\n        let rule = this.rule, oRule = other.rule;\n        return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props);\n    }\n    walk(f) {\n        let rule = this.rule, expr = rule.expr.walk(f);\n        return f(expr == rule.expr ? this :\n            new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));\n    }\n}\nclass ChoiceExpression extends Expression {\n    constructor(start, exprs) {\n        super(start);\n        this.exprs = exprs;\n    }\n    toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" | \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs);\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));\n    }\n}\nChoiceExpression.prototype.prec = 1;\nclass SequenceExpression extends Expression {\n    constructor(start, exprs, markers, empty = false) {\n        super(start);\n        this.exprs = exprs;\n        this.markers = markers;\n        this.empty = empty;\n    }\n    toString() { return this.empty ? \"()\" : this.exprs.map(e => maybeParens(e, this)).join(\" \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {\n            let om = other.markers[i];\n            return m.length == om.length && m.every((x, i) => x.eq(om[i]));\n        });\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty && !exprs.length));\n    }\n}\nSequenceExpression.prototype.prec = 2;\nclass ConflictMarker extends Node {\n    constructor(start, id, type) {\n        super(start);\n        this.id = id;\n        this.type = type;\n    }\n    toString() { return (this.type == \"ambig\" ? \"~\" : \"!\") + this.id.name; }\n    eq(other) { return this.id.name == other.id.name && this.type == other.type; }\n}\nclass RepeatExpression extends Expression {\n    constructor(start, expr, kind) {\n        super(start);\n        this.expr = expr;\n        this.kind = kind;\n    }\n    toString() { return maybeParens(this.expr, this) + this.kind; }\n    eq(other) {\n        return exprEq(this.expr, other.expr) && this.kind == other.kind;\n    }\n    walk(f) {\n        let expr = this.expr.walk(f);\n        return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));\n    }\n}\nRepeatExpression.prototype.prec = 3;\nclass LiteralExpression extends Expression {\n    // value.length is always > 0\n    constructor(start, value) {\n        super(start);\n        this.value = value;\n    }\n    toString() { return JSON.stringify(this.value); }\n    eq(other) { return this.value == other.value; }\n}\nclass SetExpression extends Expression {\n    constructor(start, ranges, inverted) {\n        super(start);\n        this.ranges = ranges;\n        this.inverted = inverted;\n    }\n    toString() {\n        return `[${this.inverted ? \"^\" : \"\"}${this.ranges.map(([a, b]) => {\n            return String.fromCodePoint(a) + (b == a + 1 ? \"\" : \"-\" + String.fromCodePoint(b));\n        })}]`;\n    }\n    eq(other) {\n        return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&\n            this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y; });\n    }\n}\nclass AnyExpression extends Expression {\n    constructor(start) {\n        super(start);\n    }\n    toString() { return \"_\"; }\n    eq() { return true; }\n}\nfunction walkExprs(exprs, f) {\n    let result = null;\n    for (let i = 0; i < exprs.length; i++) {\n        let expr = exprs[i].walk(f);\n        if (expr != exprs[i] && !result)\n            result = exprs.slice(0, i);\n        if (result)\n            result.push(expr);\n    }\n    return result || exprs;\n}\nconst CharClasses = {\n    asciiLetter: [[65, 91], [97, 123]],\n    asciiLowercase: [[97, 123]],\n    asciiUppercase: [[65, 91]],\n    digit: [[48, 58]],\n    whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],\n        [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],\n    eof: [[0xffff, 0xffff]]\n};\nclass CharClass extends Expression {\n    constructor(start, type) {\n        super(start);\n        this.type = type;\n    }\n    toString() { return \"@\" + this.type; }\n    eq(expr) { return this.type == expr.type; }\n}\nfunction exprEq(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nfunction exprsEq(a, b) {\n    return a.length == b.length && a.every((e, i) => exprEq(e, b[i]));\n}\nclass Prop extends Node {\n    constructor(start, at, name, value) {\n        super(start);\n        this.at = at;\n        this.name = name;\n        this.value = value;\n    }\n    eq(other) {\n        return this.name == other.name && this.value.length == other.value.length &&\n            this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name);\n    }\n    toString() {\n        let result = (this.at ? \"@\" : \"\") + this.name;\n        if (this.value.length) {\n            result += \"=\";\n            for (let { name, value } of this.value)\n                result += name ? `{${name}}` : /[^\\w-]/.test(value) ? JSON.stringify(value) : value;\n        }\n        return result;\n    }\n    static eqProps(a, b) {\n        return a.length == b.length && a.every((p, i) => p.eq(b[i]));\n    }\n}\nclass PropPart extends Node {\n    constructor(start, value, name) {\n        super(start);\n        this.value = value;\n        this.name = name;\n    }\n}\nfunction maybeParens(node, parent) {\n    return node.prec < parent.prec ? \"(\" + node.toString() + \")\" : node.toString();\n}\n\n/**\nThe type of error raised when the parser generator finds an issue.\n*/\nclass GenError extends Error {\n}\n\nfunction hasProps(props) {\n    for (let _p in props)\n        return true;\n    return false;\n}\nlet termHash = 0;\nclass Term {\n    constructor(name, flags, nodeName, props = {}) {\n        this.name = name;\n        this.flags = flags;\n        this.nodeName = nodeName;\n        this.props = props;\n        this.hash = ++termHash; // Used for sorting and hashing during parser generation\n        this.id = -1; // Assigned in a later stage, used in actual output\n        // Filled in only after the rules are simplified, used in automaton.ts\n        this.rules = [];\n    }\n    toString() { return this.name; }\n    get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }\n    get terminal() { return (this.flags & 1 /* TermFlag.Terminal */) > 0; }\n    get eof() { return (this.flags & 4 /* TermFlag.Eof */) > 0; }\n    get error() { return \"error\" in this.props; }\n    get top() { return (this.flags & 2 /* TermFlag.Top */) > 0; }\n    get interesting() { return this.flags > 0 || this.nodeName != null; }\n    get repeated() { return (this.flags & 16 /* TermFlag.Repeated */) > 0; }\n    set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags & ~8 /* TermFlag.Preserve */; }\n    get preserve() { return (this.flags & 8 /* TermFlag.Preserve */) > 0; }\n    set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags & ~32 /* TermFlag.Inline */; }\n    get inline() { return (this.flags & 32 /* TermFlag.Inline */) > 0; }\n    cmp(other) { return this.hash - other.hash; }\n}\nclass TermSet {\n    constructor() {\n        this.terms = [];\n        // Map from term names to Term instances\n        this.names = Object.create(null);\n        this.tops = [];\n        this.eof = this.term(\"\", null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);\n        this.error = this.term(\"\", \"\", 8 /* TermFlag.Preserve */);\n    }\n    term(name, nodeName, flags = 0, props = {}) {\n        let term = new Term(name, flags, nodeName, props);\n        this.terms.push(term);\n        this.names[name] = term;\n        return term;\n    }\n    makeTop(nodeName, props) {\n        const term = this.term(\"@top\", nodeName, 2 /* TermFlag.Top */, props);\n        this.tops.push(term);\n        return term;\n    }\n    makeTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);\n    }\n    makeNonTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 0, props);\n    }\n    makeRepeat(name) {\n        return this.term(name, null, 16 /* TermFlag.Repeated */);\n    }\n    uniqueName(name) {\n        for (let i = 0;; i++) {\n            let cur = i ? `${name}-${i}` : name;\n            if (!this.names[cur])\n                return cur;\n        }\n    }\n    finish(rules) {\n        for (let rule of rules)\n            rule.name.rules.push(rule);\n        this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)));\n        let names = {};\n        let nodeTypes = [this.error];\n        this.error.id = 0 /* T.Err */;\n        let nextID = 0 /* T.Err */ + 1;\n        // Assign ids to terms that represent node types\n        for (let term of this.terms)\n            if (term.id < 0 && term.nodeType && !term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Put all repeated terms after the regular node types\n        let minRepeatTerm = nextID;\n        for (let term of this.terms)\n            if (term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Then comes the EOF term\n        this.eof.id = nextID++;\n        // And then the remaining (non-node, non-repeat) terms.\n        for (let term of this.terms) {\n            if (term.id < 0)\n                term.id = nextID++;\n            if (term.name)\n                names[term.id] = term.name;\n        }\n        if (nextID >= 0xfffe)\n            throw new GenError(\"Too many terms\");\n        return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };\n    }\n}\nfunction cmpSet(a, b, cmp) {\n    if (a.length != b.length)\n        return a.length - b.length;\n    for (let i = 0; i < a.length; i++) {\n        let diff = cmp(a[i], b[i]);\n        if (diff)\n            return diff;\n    }\n    return 0;\n}\nconst none$3 = [];\nclass Conflicts {\n    constructor(precedence, ambigGroups = none$3, cut = 0) {\n        this.precedence = precedence;\n        this.ambigGroups = ambigGroups;\n        this.cut = cut;\n    }\n    join(other) {\n        if (this == Conflicts.none || this == other)\n            return other;\n        if (other == Conflicts.none)\n            return this;\n        return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));\n    }\n    cmp(other) {\n        return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||\n            this.cut - other.cut;\n    }\n}\nConflicts.none = new Conflicts(0);\nfunction union(a, b) {\n    if (a.length == 0 || a == b)\n        return b;\n    if (b.length == 0)\n        return a;\n    let result = a.slice();\n    for (let value of b)\n        if (!a.includes(value))\n            result.push(value);\n    return result.sort();\n}\nlet ruleID = 0;\nclass Rule {\n    constructor(name, parts, conflicts, skip) {\n        this.name = name;\n        this.parts = parts;\n        this.conflicts = conflicts;\n        this.skip = skip;\n        this.id = ruleID++;\n    }\n    cmp(rule) {\n        return this.id - rule.id;\n    }\n    cmpNoName(rule) {\n        return this.parts.length - rule.parts.length ||\n            this.skip.hash - rule.skip.hash ||\n            this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||\n            cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b));\n    }\n    toString() {\n        return this.name + \" -> \" + this.parts.join(\" \");\n    }\n    get isRepeatWrap() {\n        return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name;\n    }\n    sameReduce(other) {\n        return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap;\n    }\n}\n\nconst MAX_CHAR = 0xffff;\nclass Edge {\n    constructor(from, to, target) {\n        this.from = from;\n        this.to = to;\n        this.target = target;\n    }\n    toString() {\n        return `-> ${this.target.id}[label=${JSON.stringify(this.from < 0 ? \"\" : charFor(this.from) +\n            (this.to > this.from + 1 ? \"-\" + charFor(this.to - 1) : \"\"))}]`;\n    }\n}\nfunction charFor(n) {\n    return n > MAX_CHAR ? \"\"\n        : n == 10 ? \"\\\\n\"\n            : n == 13 ? \"\\\\r\"\n                : n < 32 || n >= 0xd800 && n < 0xdfff ? \"\\\\u{\" + n.toString(16) + \"}\"\n                    : String.fromCharCode(n);\n}\nfunction minimize(states, start) {\n    let partition = Object.create(null);\n    let byAccepting = Object.create(null);\n    for (let state of states) {\n        let id = ids(state.accepting);\n        let group = byAccepting[id] || (byAccepting[id] = []);\n        group.push(state);\n        partition[state.id] = group;\n    }\n    for (;;) {\n        let split = false, newPartition = Object.create(null);\n        for (let state of states) {\n            if (newPartition[state.id])\n                continue;\n            let group = partition[state.id];\n            if (group.length == 1) {\n                newPartition[group[0].id] = group;\n                continue;\n            }\n            let parts = [];\n            groups: for (let state of group) {\n                for (let p of parts) {\n                    if (isEquivalent(state, p[0], partition)) {\n                        p.push(state);\n                        continue groups;\n                    }\n                }\n                parts.push([state]);\n            }\n            if (parts.length > 1)\n                split = true;\n            for (let p of parts)\n                for (let s of p)\n                    newPartition[s.id] = p;\n        }\n        if (!split)\n            return applyMinimization(states, start, partition);\n        partition = newPartition;\n    }\n}\nfunction isEquivalent(a, b, partition) {\n    if (a.edges.length != b.edges.length)\n        return false;\n    for (let i = 0; i < a.edges.length; i++) {\n        let eA = a.edges[i], eB = b.edges[i];\n        if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])\n            return false;\n    }\n    return true;\n}\nfunction applyMinimization(states, start, partition) {\n    for (let state of states) {\n        for (let i = 0; i < state.edges.length; i++) {\n            let edge = state.edges[i], target = partition[edge.target.id][0];\n            if (target != edge.target)\n                state.edges[i] = new Edge(edge.from, edge.to, target);\n        }\n    }\n    return partition[start.id][0];\n}\nlet stateID = 1;\nlet State$1 = class State {\n    constructor(accepting = [], id = stateID++) {\n        this.accepting = accepting;\n        this.id = id;\n        this.edges = [];\n    }\n    edge(from, to, target) {\n        this.edges.push(new Edge(from, to, target));\n    }\n    nullEdge(target) { this.edge(-1, -1, target); }\n    compile() {\n        let labeled = Object.create(null), localID = 0;\n        let startState = explore(this.closure().sort((a, b) => a.id - b.id));\n        return minimize(Object.values(labeled), startState);\n        function explore(states) {\n            let newState = labeled[ids(states)] =\n                new State(states.reduce((a, s) => union(a, s.accepting), []), localID++);\n            let out = [];\n            for (let state of states)\n                for (let edge of state.edges) {\n                    if (edge.from >= 0)\n                        out.push(edge);\n                }\n            let transitions = mergeEdges(out);\n            for (let merged of transitions) {\n                let targets = merged.targets.sort((a, b) => a.id - b.id);\n                newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));\n            }\n            return newState;\n        }\n    }\n    closure() {\n        let result = [], seen = Object.create(null);\n        function explore(state) {\n            if (seen[state.id])\n                return;\n            seen[state.id] = true;\n            // States with only epsilon edges and no accepting term that\n            // isn't also in the next states are left out to help reduce the\n            // number of unique state combinations\n            if (state.edges.some(e => e.from >= 0) ||\n                (state.accepting.length > 0 && !state.edges.some(e => sameSet$1(state.accepting, e.target.accepting))))\n                result.push(state);\n            for (let edge of state.edges)\n                if (edge.from < 0)\n                    explore(edge.target);\n        }\n        explore(this);\n        return result;\n    }\n    findConflicts(occurTogether) {\n        let conflicts = [], cycleTerms = this.cycleTerms();\n        function add(a, b, soft, aEdges, bEdges) {\n            if (a.id < b.id) {\n                [a, b] = [b, a];\n                soft = -soft;\n            }\n            let found = conflicts.find(c => c.a == a && c.b == b);\n            if (!found)\n                conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)));\n            else if (found.soft != soft)\n                found.soft = 0;\n        }\n        this.reachable((state, edges) => {\n            if (state.accepting.length == 0)\n                return;\n            for (let i = 0; i < state.accepting.length; i++)\n                for (let j = i + 1; j < state.accepting.length; j++)\n                    add(state.accepting[i], state.accepting[j], 0, edges);\n            state.reachable((s, es) => {\n                if (s != state)\n                    for (let term of s.accepting) {\n                        let hasCycle = cycleTerms.includes(term);\n                        for (let orig of state.accepting)\n                            if (term != orig)\n                                add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));\n                    }\n            });\n        });\n        return conflicts;\n    }\n    cycleTerms() {\n        let work = [];\n        this.reachable(state => {\n            for (let { target } of state.edges)\n                work.push(state, target);\n        });\n        let table = new Map;\n        let haveCycle = [];\n        for (let i = 0; i < work.length;) {\n            let from = work[i++], to = work[i++];\n            let entry = table.get(from);\n            if (!entry)\n                table.set(from, entry = []);\n            if (entry.includes(to))\n                continue;\n            if (from == to) {\n                if (!haveCycle.includes(from))\n                    haveCycle.push(from);\n            }\n            else {\n                for (let next of entry)\n                    work.push(from, next);\n                entry.push(to);\n            }\n        }\n        let result = [];\n        for (let state of haveCycle) {\n            for (let term of state.accepting) {\n                if (!result.includes(term))\n                    result.push(term);\n            }\n        }\n        return result;\n    }\n    reachable(f) {\n        let seen = [], edges = [];\n        (function explore(s) {\n            f(s, edges);\n            seen.push(s);\n            for (let edge of s.edges)\n                if (!seen.includes(edge.target)) {\n                    edges.push(edge);\n                    explore(edge.target);\n                    edges.pop();\n                }\n        })(this);\n    }\n    toString() {\n        let out = \"digraph {\\n\";\n        this.reachable(state => {\n            if (state.accepting.length)\n                out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\\n`;\n            for (let edge of state.edges)\n                out += `  ${state.id} ${edge};\\n`;\n        });\n        return out + \"}\";\n    }\n    // Tokenizer data is represented as a single flat array. This\n    // contains regions for each tokenizer state. Region offsets are\n    // used to identify states.\n    //\n    // Each state is laid out as:\n    //  - Token group mask\n    //  - Offset of the end of the accepting data\n    //  - Number of outgoing edges in the state\n    //  - Pairs of token masks and term ids that indicate the accepting\n    //    states, sorted by precedence\n    //  - Triples for the edges: each with a low and high bound and the\n    //    offset of the next state.\n    toArray(groupMasks, precedence) {\n        let offsets = []; // Used to 'link' the states after building the arrays\n        let data = [];\n        this.reachable(state => {\n            let start = data.length;\n            let acceptEnd = start + 3 + state.accepting.length * 2;\n            offsets[state.id] = start;\n            data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);\n            state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id));\n            for (let term of state.accepting)\n                data.push(term.id, groupMasks[term.id] || 0xffff);\n            for (let edge of state.edges)\n                data.push(edge.from, edge.to, -edge.target.id - 1);\n        });\n        // Replace negative numbers with resolved state offsets\n        for (let i = 0; i < data.length; i++)\n            if (data[i] < 0)\n                data[i] = offsets[-data[i] - 1];\n        if (data.length > Math.pow(2, 16))\n            throw new GenError(\"Tokenizer tables too big to represent with 16-bit offsets.\");\n        return Uint16Array.from(data);\n    }\n    stateMask(groupMasks) {\n        let mask = 0;\n        this.reachable(state => {\n            for (let term of state.accepting)\n                mask |= (groupMasks[term.id] || 0xffff);\n        });\n        return mask;\n    }\n};\nlet Conflict$1 = class Conflict {\n    constructor(a, b, \n    // Conflicts between two non-cyclic tokens are marked as\n    // 'soft', with a negative number if a is shorter than\n    // b, and a positive if b is shorter than a.\n    soft, exampleA, exampleB) {\n        this.a = a;\n        this.b = b;\n        this.soft = soft;\n        this.exampleA = exampleA;\n        this.exampleB = exampleB;\n    }\n};\nfunction exampleFromEdges(edges) {\n    let str = \"\";\n    for (let i = 0; i < edges.length; i++)\n        str += String.fromCharCode(edges[i].from);\n    return str;\n}\nfunction ids(elts) {\n    let result = \"\";\n    for (let elt of elts) {\n        if (result.length)\n            result += \"-\";\n        result += elt.id;\n    }\n    return result;\n}\nfunction sameSet$1(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass MergedEdge {\n    constructor(from, to, targets) {\n        this.from = from;\n        this.to = to;\n        this.targets = targets;\n    }\n}\n// Merge multiple edges (tagged by character ranges) into a set of\n// mutually exclusive ranges pointing at all target states for that\n// range\nfunction mergeEdges(edges) {\n    let separate = [], result = [];\n    for (let edge of edges) {\n        if (!separate.includes(edge.from))\n            separate.push(edge.from);\n        if (!separate.includes(edge.to))\n            separate.push(edge.to);\n    }\n    separate.sort((a, b) => a - b);\n    for (let i = 1; i < separate.length; i++) {\n        let from = separate[i - 1], to = separate[i];\n        let found = [];\n        for (let edge of edges)\n            if (edge.to > from && edge.from < to) {\n                for (let target of edge.target.closure())\n                    if (!found.includes(target))\n                        found.push(target);\n            }\n        if (found.length)\n            result.push(new MergedEdge(from, to, found));\n    }\n    let eof = edges.filter(e => e.from == 65535 /* Seq.End */ && e.to == 65535 /* Seq.End */);\n    if (eof.length) {\n        let found = [];\n        for (let edge of eof)\n            for (let target of edge.target.closure())\n                if (!found.includes(target))\n                    found.push(target);\n        if (found.length)\n            result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));\n    }\n    return result;\n}\n\n// Note that this is the parser for grammar files, not the generated parser\nlet word = /[\\w_-]+/gy;\n// Some engines (specifically SpiderMonkey) have still not implemented \\p\ntry {\n    word = /[\\p{Alphabetic}\\d_-]+/ugy;\n}\ncatch (_) { }\nconst none$2 = [];\nclass Input {\n    constructor(string, fileName = null) {\n        this.string = string;\n        this.fileName = fileName;\n        this.type = \"sof\";\n        this.value = null;\n        this.start = 0;\n        this.end = 0;\n        this.next();\n    }\n    lineInfo(pos) {\n        for (let line = 1, cur = 0;;) {\n            let next = this.string.indexOf(\"\\n\", cur);\n            if (next > -1 && next < pos) {\n                ++line;\n                cur = next + 1;\n            }\n            else {\n                return { line, ch: pos - cur };\n            }\n        }\n    }\n    message(msg, pos = -1) {\n        let posInfo = this.fileName || \"\";\n        if (pos > -1) {\n            let info = this.lineInfo(pos);\n            posInfo += (posInfo ? \" \" : \"\") + info.line + \":\" + info.ch;\n        }\n        return posInfo ? msg + ` (${posInfo})` : msg;\n    }\n    raise(msg, pos = -1) {\n        throw new GenError(this.message(msg, pos));\n    }\n    match(pos, re) {\n        let match = re.exec(this.string.slice(pos));\n        return match ? pos + match[0].length : -1;\n    }\n    next() {\n        let start = this.match(this.end, /^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n        if (start == this.string.length)\n            return this.set(\"eof\", null, start, start);\n        let next = this.string[start];\n        if (next == '\"') {\n            let end = this.match(start + 1, /^(\\\\.|[^\"\\\\])*\"/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"'\") {\n            let end = this.match(start + 1, /^(\\\\.|[^'\\\\])*'/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"@\") {\n            word.lastIndex = start + 1;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"@ without a name\", start);\n            return this.set(\"at\", m[0], start, start + 1 + m[0].length);\n        }\n        else if ((next == \"$\" || next == \"!\") && this.string[start + 1] == \"[\") {\n            let end = this.match(start + 2, /^(?:\\\\.|[^\\]\\\\])*\\]/);\n            if (end == -1)\n                this.raise(\"Unterminated character set\", start);\n            return this.set(\"set\", this.string.slice(start + 2, end - 1), start, end);\n        }\n        else if (/[\\[\\]()!~+*?{}<>\\.,|:$=]/.test(next)) {\n            return this.set(next, null, start, start + 1);\n        }\n        else {\n            word.lastIndex = start;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"Unexpected character \" + JSON.stringify(next), start);\n            return this.set(\"id\", m[0], start, start + m[0].length);\n        }\n    }\n    set(type, value, start, end) {\n        this.type = type;\n        this.value = value;\n        this.start = start;\n        this.end = end;\n    }\n    eat(type, value = null) {\n        if (this.type == type && (value == null || this.value === value)) {\n            this.next();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    unexpected() {\n        return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);\n    }\n    expect(type, value = null) {\n        let val = this.value;\n        if (this.type != type || !(value == null || val === value))\n            this.unexpected();\n        this.next();\n        return val;\n    }\n    parse() {\n        return parseGrammar(this);\n    }\n}\nfunction parseGrammar(input) {\n    let start = input.start;\n    let rules = [];\n    let prec = null;\n    let tokens = null;\n    let localTokens = [];\n    let mainSkip = null;\n    let scopedSkip = [];\n    let dialects = [];\n    let context = null;\n    let external = [];\n    let specialized = [];\n    let props = [];\n    let propSources = [];\n    let tops = [];\n    let sawTop = false;\n    let autoDelim = false;\n    while (input.type != \"eof\") {\n        let start = input.start;\n        if (input.eat(\"at\", \"top\")) {\n            if (input.type != \"id\")\n                input.raise(`Top rules must have a name`, input.start);\n            tops.push(parseRule(input, parseIdent(input)));\n            sawTop = true;\n        }\n        else if (input.type == \"at\" && input.value == \"tokens\") {\n            if (tokens)\n                input.raise(`Multiple @tokens declaractions`, input.start);\n            else\n                tokens = parseTokens(input);\n        }\n        else if (input.eat(\"at\", \"local\")) {\n            input.expect(\"id\", \"tokens\");\n            localTokens.push(parseLocalTokens(input, start));\n        }\n        else if (input.eat(\"at\", \"context\")) {\n            if (context)\n                input.raise(`Multiple @context declarations`, start);\n            let id = parseIdent(input);\n            input.expect(\"id\", \"from\");\n            let source = input.expect(\"string\");\n            context = new ContextDeclaration(start, id, source);\n        }\n        else if (input.eat(\"at\", \"external\")) {\n            if (input.eat(\"id\", \"tokens\"))\n                external.push(parseExternalTokens(input, start));\n            else if (input.eat(\"id\", \"prop\"))\n                props.push(parseExternalProp(input, start));\n            else if (input.eat(\"id\", \"extend\"))\n                specialized.push(parseExternalSpecialize(input, \"extend\", start));\n            else if (input.eat(\"id\", \"specialize\"))\n                specialized.push(parseExternalSpecialize(input, \"specialize\", start));\n            else if (input.eat(\"id\", \"propSource\"))\n                propSources.push(parseExternalPropSource(input, start));\n            else\n                input.unexpected();\n        }\n        else if (input.eat(\"at\", \"dialects\")) {\n            input.expect(\"{\");\n            for (let first = true; !input.eat(\"}\"); first = false) {\n                if (!first)\n                    input.eat(\",\");\n                dialects.push(parseIdent(input));\n            }\n        }\n        else if (input.type == \"at\" && input.value == \"precedence\") {\n            if (prec)\n                input.raise(`Multiple precedence declarations`, input.start);\n            prec = parsePrecedence(input);\n        }\n        else if (input.eat(\"at\", \"detectDelim\")) {\n            autoDelim = true;\n        }\n        else if (input.eat(\"at\", \"skip\")) {\n            let skip = parseBracedExpr(input);\n            if (input.type == \"{\") {\n                input.next();\n                let rules = [], topRules = [];\n                while (!input.eat(\"}\")) {\n                    if (input.eat(\"at\", \"top\")) {\n                        topRules.push(parseRule(input, parseIdent(input)));\n                        sawTop = true;\n                    }\n                    else {\n                        rules.push(parseRule(input));\n                    }\n                }\n                scopedSkip.push({ expr: skip, topRules, rules });\n            }\n            else {\n                if (mainSkip)\n                    input.raise(`Multiple top-level skip declarations`, input.start);\n                mainSkip = skip;\n            }\n        }\n        else {\n            rules.push(parseRule(input));\n        }\n    }\n    if (!sawTop)\n        return input.raise(`Missing @top declaration`);\n    return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);\n}\nfunction parseRule(input, named) {\n    let start = named ? named.start : input.start;\n    let id = named || parseIdent(input);\n    let props = parseProps(input);\n    let params = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (params.length)\n                input.expect(\",\");\n            params.push(parseIdent(input));\n        }\n    let expr = parseBracedExpr(input);\n    return new RuleDeclaration(start, id, props, params, expr);\n}\nfunction parseProps(input) {\n    if (input.type != \"[\")\n        return none$2;\n    let props = [];\n    input.expect(\"[\");\n    while (!input.eat(\"]\")) {\n        if (props.length)\n            input.expect(\",\");\n        props.push(parseProp(input));\n    }\n    return props;\n}\nfunction parseProp(input) {\n    let start = input.start, value = [], name = input.value, at = input.type == \"at\";\n    if (!input.eat(\"at\") && !input.eat(\"id\"))\n        input.unexpected();\n    if (input.eat(\"=\"))\n        for (;;) {\n            if (input.type == \"string\" || input.type == \"id\") {\n                value.push(new PropPart(input.start, input.value, null));\n                input.next();\n            }\n            else if (input.eat(\".\")) {\n                value.push(new PropPart(input.start, \".\", null));\n            }\n            else if (input.eat(\"{\")) {\n                value.push(new PropPart(input.start, null, input.expect(\"id\")));\n                input.expect(\"}\");\n            }\n            else {\n                break;\n            }\n        }\n    return new Prop(start, at, name, value);\n}\nfunction parseBracedExpr(input) {\n    input.expect(\"{\");\n    let expr = parseExprChoice(input);\n    input.expect(\"}\");\n    return expr;\n}\nconst SET_MARKER = \"\\ufdda\"; // (Invalid unicode character)\nfunction parseExprInner(input) {\n    let start = input.start;\n    if (input.eat(\"(\")) {\n        if (input.eat(\")\"))\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        let expr = parseExprChoice(input);\n        input.expect(\")\");\n        return expr;\n    }\n    else if (input.type == \"string\") {\n        let value = input.value;\n        input.next();\n        if (value.length == 0)\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        return new LiteralExpression(start, value);\n    }\n    else if (input.eat(\"id\", \"_\")) {\n        return new AnyExpression(start);\n    }\n    else if (input.type == \"set\") {\n        let content = input.value, invert = input.string[input.start] == \"!\";\n        let unescaped = readString(content.replace(/\\\\.|-|\"/g, (m) => {\n            return m == \"-\" ? SET_MARKER : m == '\"' ? '\\\\\"' : m;\n        }));\n        let ranges = [];\n        for (let pos = 0; pos < unescaped.length;) {\n            let code = unescaped.codePointAt(pos);\n            pos += code > 0xffff ? 2 : 1;\n            if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {\n                let end = unescaped.codePointAt(pos + 1);\n                pos += end > 0xffff ? 3 : 2;\n                if (end < code)\n                    input.raise(\"Invalid character range\", input.start);\n                addRange(input, ranges, code, end + 1);\n            }\n            else {\n                if (code == SET_MARKER.charCodeAt(0))\n                    code = 45;\n                addRange(input, ranges, code, code + 1);\n            }\n        }\n        input.next();\n        return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert);\n    }\n    else if (input.type == \"at\" && (input.value == \"specialize\" || input.value == \"extend\")) {\n        let { start, value } = input;\n        input.next();\n        let props = parseProps(input);\n        input.expect(\"<\");\n        let token = parseExprChoice(input), content;\n        if (input.eat(\",\")) {\n            content = parseExprChoice(input);\n        }\n        else if (token instanceof LiteralExpression) {\n            content = token;\n        }\n        else {\n            input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);\n        }\n        input.expect(\">\");\n        return new SpecializeExpression(start, value, props, token, content);\n    }\n    else if (input.type == \"at\" && CharClasses.hasOwnProperty(input.value)) {\n        let cls = new CharClass(input.start, input.value);\n        input.next();\n        return cls;\n    }\n    else if (input.type == \"[\") {\n        let rule = parseRule(input, new Identifier(start, \"_anon\"));\n        if (rule.params.length)\n            input.raise(`Inline rules can't have parameters`, rule.start);\n        return new InlineRuleExpression(start, rule);\n    }\n    else {\n        let id = parseIdent(input);\n        if (input.type == \"[\" || input.type == \"{\") {\n            let rule = parseRule(input, id);\n            if (rule.params.length)\n                input.raise(`Inline rules can't have parameters`, rule.start);\n            return new InlineRuleExpression(start, rule);\n        }\n        else {\n            if (input.eat(\".\") && id.name == \"std\" && CharClasses.hasOwnProperty(input.value)) {\n                let cls = new CharClass(start, input.value);\n                input.next();\n                return cls;\n            }\n            return new NameExpression(start, id, parseArgs(input));\n        }\n    }\n}\nfunction parseArgs(input) {\n    let args = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (args.length)\n                input.expect(\",\");\n            args.push(parseExprChoice(input));\n        }\n    return args;\n}\nfunction addRange(input, ranges, from, to) {\n    if (!ranges.every(([a, b]) => b <= from || a >= to))\n        input.raise(\"Overlapping character range\", input.start);\n    ranges.push([from, to]);\n}\nfunction parseExprSuffix(input) {\n    let start = input.start;\n    let expr = parseExprInner(input);\n    for (;;) {\n        let kind = input.type;\n        if (input.eat(\"*\") || input.eat(\"?\") || input.eat(\"+\"))\n            expr = new RepeatExpression(start, expr, kind);\n        else\n            return expr;\n    }\n}\nfunction endOfSequence(input) {\n    return input.type == \"}\" || input.type == \")\" || input.type == \"|\" || input.type == \"/\" ||\n        input.type == \"/\\\\\" || input.type == \"{\" || input.type == \",\" || input.type == \">\";\n}\nfunction parseExprSequence(input) {\n    let start = input.start, exprs = [], markers = [none$2];\n    do {\n        // Add markers at this position\n        for (;;) {\n            let localStart = input.start, markerType;\n            if (input.eat(\"~\"))\n                markerType = \"ambig\";\n            else if (input.eat(\"!\"))\n                markerType = \"prec\";\n            else\n                break;\n            markers[markers.length - 1] =\n                markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));\n        }\n        if (endOfSequence(input))\n            break;\n        exprs.push(parseExprSuffix(input));\n        markers.push(none$2);\n    } while (!endOfSequence(input));\n    if (exprs.length == 1 && markers.every(ms => ms.length == 0))\n        return exprs[0];\n    return new SequenceExpression(start, exprs, markers, !exprs.length);\n}\nfunction parseExprChoice(input) {\n    let start = input.start, left = parseExprSequence(input);\n    if (!input.eat(\"|\"))\n        return left;\n    let exprs = [left];\n    do {\n        exprs.push(parseExprSequence(input));\n    } while (input.eat(\"|\"));\n    let empty = exprs.find(s => s instanceof SequenceExpression && s.empty);\n    if (empty)\n        input.raise(\"Empty expression in choice operator. If this is intentional, use () to make it explicit.\", empty.start);\n    return new ChoiceExpression(start, exprs);\n}\nfunction parseIdent(input) {\n    if (input.type != \"id\")\n        input.unexpected();\n    let start = input.start, name = input.value;\n    input.next();\n    return new Identifier(start, name);\n}\nfunction parsePrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let items = [];\n    while (!input.eat(\"}\")) {\n        if (items.length)\n            input.eat(\",\");\n        items.push({\n            id: parseIdent(input),\n            type: input.eat(\"at\", \"left\") ? \"left\" : input.eat(\"at\", \"right\") ? \"right\" : input.eat(\"at\", \"cut\") ? \"cut\" : null\n        });\n    }\n    return new PrecDeclaration(start, items);\n}\nfunction parseTokens(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokenRules = [];\n    let literals = [];\n    let precedences = [];\n    let conflicts = [];\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.type == \"at\" && input.value == \"conflict\") {\n            conflicts.push(parseTokenConflict(input));\n        }\n        else if (input.type == \"string\") {\n            literals.push(new LiteralDeclaration(input.start, input.expect(\"string\"), parseProps(input)));\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);\n}\nfunction parseLocalTokens(input, start) {\n    input.expect(\"{\");\n    let tokenRules = [];\n    let precedences = [];\n    let fallback = null;\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.eat(\"at\", \"else\") && !fallback) {\n            fallback = { id: parseIdent(input), props: parseProps(input) };\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);\n}\nfunction parseTokenPrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokens = [];\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let expr = parseExprInner(input);\n        if (expr instanceof LiteralExpression || expr instanceof NameExpression)\n            tokens.push(expr);\n        else\n            input.raise(`Invalid expression in token precedences`, expr.start);\n    }\n    return new TokenPrecDeclaration(start, tokens);\n}\nfunction parseTokenConflict(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let a = parseExprInner(input);\n    if (!(a instanceof LiteralExpression || a instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, a.start);\n    input.eat(\",\");\n    let b = parseExprInner(input);\n    if (!(b instanceof LiteralExpression || b instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, b.start);\n    input.expect(\"}\");\n    return new TokenConflictDeclaration(start, a, b);\n}\nfunction parseExternalTokenSet(input) {\n    let tokens = [];\n    input.expect(\"{\");\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let id = parseIdent(input);\n        let props = parseProps(input);\n        tokens.push({ id, props });\n    }\n    return tokens;\n}\nfunction parseExternalTokens(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalSpecialize(input, type, start) {\n    let token = parseBracedExpr(input);\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalPropSource(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    return new ExternalPropSourceDeclaration(start, id, input.expect(\"string\"));\n}\nfunction parseExternalProp(input, start) {\n    let externalID = parseIdent(input);\n    let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID;\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalPropDeclaration(start, id, externalID, from);\n}\nfunction readString(string) {\n    let point = /\\\\(?:u\\{([\\da-f]+)\\}|u([\\da-f]{4})|x([\\da-f]{2})|([ntbrf0])|(.))|[^]/yig;\n    let out = \"\", m;\n    while (m = point.exec(string)) {\n        let [all, u1, u2, u3, single, unknown] = m;\n        if (u1 || u2 || u3)\n            out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));\n        else if (single)\n            out += single == \"n\" ? \"\\n\" : single == \"t\" ? \"\\t\" : single == \"0\" ? \"\\0\" : single == \"r\" ? \"\\r\" : single == \"f\" ? \"\\f\" : \"\\b\";\n        else if (unknown)\n            out += unknown;\n        else\n            out += all;\n    }\n    return out;\n}\n\nfunction hash(a, b) { return (a << 5) + a + b; }\nfunction hashString(h, s) {\n    for (let i = 0; i < s.length; i++)\n        h = hash(h, s.charCodeAt(i));\n    return h;\n}\n\nconst verbose = (typeof process != \"undefined\" && process.env.LOG) || \"\";\nconst timing = /\\btime\\b/.test(verbose);\nconst time = timing ? (label, f) => {\n    let t0 = Date.now();\n    let result = f();\n    console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n    return result;\n} : (_label, f) => f();\n\nclass Pos {\n    constructor(rule, pos, \n    // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called\n    ahead, ambigAhead, skipAhead, via) {\n        this.rule = rule;\n        this.pos = pos;\n        this.ahead = ahead;\n        this.ambigAhead = ambigAhead;\n        this.skipAhead = skipAhead;\n        this.via = via;\n        this.hash = 0;\n    }\n    finish() {\n        let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);\n        for (let a of this.ahead)\n            h = hash(h, a.hash);\n        for (let group of this.ambigAhead)\n            h = hashString(h, group);\n        this.hash = h;\n        return this;\n    }\n    get next() {\n        return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null;\n    }\n    advance() {\n        return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();\n    }\n    get skip() {\n        return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;\n    }\n    cmp(pos) {\n        return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||\n            cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);\n    }\n    eqSimple(pos) {\n        return pos.rule == this.rule && pos.pos == this.pos;\n    }\n    toString() {\n        let parts = this.rule.parts.map(t => t.name);\n        parts.splice(this.pos, 0, \"\");\n        return `${this.rule.name} -> ${parts.join(\" \")}`;\n    }\n    eq(other) {\n        return this == other ||\n            this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&\n                sameSet(this.ahead, other.ahead) &&\n                sameSet(this.ambigAhead, other.ambigAhead);\n    }\n    trail(maxLen = 60) {\n        let result = [];\n        for (let pos = this; pos; pos = pos.via) {\n            for (let i = pos.pos - 1; i >= 0; i--)\n                result.push(pos.rule.parts[i]);\n        }\n        let value = result.reverse().join(\" \");\n        if (value.length > maxLen)\n            value = value.slice(value.length - maxLen).replace(/.*? /, \" \");\n        return value;\n    }\n    conflicts(pos = this.pos) {\n        let result = this.rule.conflicts[pos];\n        if (pos == this.rule.parts.length && this.ambigAhead.length)\n            result = result.join(new Conflicts(0, this.ambigAhead));\n        return result;\n    }\n    static addOrigins(group, context) {\n        let result = group.slice();\n        for (let i = 0; i < result.length; i++) {\n            let next = result[i];\n            if (next.pos == 0)\n                for (let pos of context) {\n                    if (pos.next == next.rule.name && !result.includes(pos))\n                        result.push(pos);\n                }\n        }\n        return result;\n    }\n}\nfunction conflictsAt(group) {\n    let result = Conflicts.none;\n    for (let pos of group)\n        result = result.join(pos.conflicts());\n    return result;\n}\n// Applies automatic action precedence based on repeat productions.\n// These are left-associative, so reducing the `R -> R R` rule has\n// higher precedence.\nfunction compareRepeatPrec(a, b) {\n    for (let pos of a)\n        if (pos.rule.name.repeated) {\n            for (let posB of b)\n                if (posB.rule.name == pos.rule.name) {\n                    if (pos.rule.isRepeatWrap && pos.pos == 2)\n                        return 1;\n                    if (posB.rule.isRepeatWrap && posB.pos == 2)\n                        return -1;\n                }\n        }\n    return 0;\n}\nfunction cmpStr(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction termsAhead(rule, pos, after, first) {\n    let found = [];\n    for (let i = pos + 1; i < rule.parts.length; i++) {\n        let next = rule.parts[i], cont = false;\n        if (next.terminal) {\n            addTo(next, found);\n        }\n        else\n            for (let term of first[next.name]) {\n                if (term == null)\n                    cont = true;\n                else\n                    addTo(term, found);\n            }\n        if (!cont)\n            return found;\n    }\n    for (let a of after)\n        addTo(a, found);\n    return found;\n}\nfunction eqSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass Shift {\n    constructor(term, target) {\n        this.term = term;\n        this.target = target;\n    }\n    eq(other) { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id; }\n    cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }\n    matches(other, mapping) {\n        return other instanceof Shift && mapping[other.target.id] == mapping[this.target.id];\n    }\n    toString() { return \"s\" + this.target.id; }\n    map(mapping, states) {\n        let mapped = states[mapping[this.target.id]];\n        return mapped == this.target ? this : new Shift(this.term, mapped);\n    }\n}\nclass Reduce {\n    constructor(term, rule) {\n        this.term = term;\n        this.rule = rule;\n    }\n    eq(other) {\n        return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule);\n    }\n    cmp(other) {\n        return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||\n            this.rule.parts.length - other.rule.parts.length;\n    }\n    matches(other, mapping) {\n        return other instanceof Reduce && other.rule.sameReduce(this.rule);\n    }\n    toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }\n    map() { return this; }\n}\nfunction hashPositions(set) {\n    let h = 5381;\n    for (let pos of set)\n        h = hash(h, pos.hash);\n    return h;\n}\nclass ConflictContext {\n    constructor(first) {\n        this.first = first;\n        this.conflicts = [];\n    }\n}\nclass State {\n    constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {\n        this.id = id;\n        this.set = set;\n        this.flags = flags;\n        this.skip = skip;\n        this.hash = hash;\n        this.startRule = startRule;\n        this.actions = [];\n        this.actionPositions = [];\n        this.goto = [];\n        this.tokenGroup = -1;\n        this.defaultReduce = null;\n        this._actionsByTerm = null;\n    }\n    toString() {\n        let actions = this.actions.map(t => t.term + \"=\" + t).join(\",\") +\n            (this.goto.length ? \" | \" + this.goto.map(g => g.term + \"=\" + g).join(\",\") : \"\");\n        return this.id + \": \" + this.set.filter(p => p.pos > 0).join() +\n            (this.defaultReduce ? `\\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`\n                : actions.length ? \"\\n  \" + actions : \"\");\n    }\n    addActionInner(value, positions) {\n        check: for (let i = 0; i < this.actions.length; i++) {\n            let action = this.actions[i];\n            if (action.term == value.term) {\n                if (action.eq(value))\n                    return null;\n                let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);\n                let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);\n                let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;\n                if (diff > 0) { // Drop the existing action\n                    this.actions.splice(i, 1);\n                    this.actionPositions.splice(i, 1);\n                    i--;\n                    continue check;\n                }\n                else if (diff < 0) { // Drop this one\n                    return null;\n                }\n                else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity\n                    continue check;\n                }\n                else { // Not resolved\n                    return action;\n                }\n            }\n        }\n        this.actions.push(value);\n        this.actionPositions.push(positions);\n        return null;\n    }\n    addAction(value, positions, context) {\n        let conflict = this.addActionInner(value, positions);\n        if (conflict) {\n            let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];\n            let rules = [positions[0].rule.name, conflictPos.rule.name];\n            if (context.conflicts.some(c => c.rules.some(r => rules.includes(r))))\n                return;\n            let error;\n            if (conflict instanceof Shift)\n                error = `shift/reduce conflict between\\n  ${conflictPos}\\nand\\n  ${positions[0].rule}`;\n            else\n                error = `reduce/reduce conflict between\\n  ${conflictPos.rule}\\nand\\n  ${positions[0].rule}`;\n            error += `\\nWith input:\\n  ${positions[0].trail(70)}  ${value.term} `;\n            if (conflict instanceof Shift)\n                error += findConflictShiftSource(positions[0], conflict.term, context.first);\n            error += findConflictOrigin(conflictPos, positions[0]);\n            context.conflicts.push(new Conflict(error, rules));\n        }\n    }\n    getGoto(term) {\n        return this.goto.find(a => a.term == term);\n    }\n    hasSet(set) {\n        return eqSet(this.set, set);\n    }\n    actionsByTerm() {\n        let result = this._actionsByTerm;\n        if (!result) {\n            this._actionsByTerm = result = Object.create(null);\n            for (let action of this.actions)\n                (result[action.term.id] || (result[action.term.id] = [])).push(action);\n        }\n        return result;\n    }\n    finish() {\n        if (this.actions.length) {\n            let first = this.actions[0];\n            if (first instanceof Reduce) {\n                let { rule } = first;\n                if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))\n                    this.defaultReduce = rule;\n            }\n        }\n        this.actions.sort((a, b) => a.cmp(b));\n        this.goto.sort((a, b) => a.cmp(b));\n    }\n    eq(other) {\n        let dThis = this.defaultReduce, dOther = other.defaultReduce;\n        if (dThis || dOther)\n            return dThis && dOther ? dThis.sameReduce(dOther) : false;\n        return this.skip == other.skip &&\n            this.tokenGroup == other.tokenGroup &&\n            eqSet(this.actions, other.actions) &&\n            eqSet(this.goto, other.goto);\n    }\n}\nfunction closure(set, first) {\n    let added = [], redo = [];\n    function addFor(name, ahead, ambigAhead, skipAhead, via) {\n        for (let rule of name.rules) {\n            let add = added.find(a => a.rule == rule);\n            if (!add) {\n                let existing = set.find(p => p.pos == 0 && p.rule == rule);\n                add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)\n                    : new Pos(rule, 0, [], none$1, skipAhead, via);\n                added.push(add);\n            }\n            if (add.skipAhead != skipAhead)\n                throw new GenError(\"Inconsistent skip sets after \" + via.trail());\n            add.ambigAhead = union(add.ambigAhead, ambigAhead);\n            for (let term of ahead)\n                if (!add.ahead.includes(term)) {\n                    add.ahead.push(term);\n                    if (add.rule.parts.length && !add.rule.parts[0].terminal)\n                        addTo(add, redo);\n                }\n        }\n    }\n    for (let pos of set) {\n        let next = pos.next;\n        if (next && !next.terminal)\n            addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);\n    }\n    while (redo.length) {\n        let add = redo.pop();\n        addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);\n    }\n    let result = set.slice();\n    for (let add of added) {\n        add.ahead.sort((a, b) => a.hash - b.hash);\n        add.finish();\n        let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule);\n        if (origIndex > -1)\n            result[origIndex] = add;\n        else\n            result.push(add);\n    }\n    return result.sort((a, b) => a.cmp(b));\n}\nfunction addTo(value, array) {\n    if (!array.includes(value))\n        array.push(value);\n}\nfunction computeFirstSets(terms) {\n    let table = Object.create(null);\n    for (let t of terms.terms)\n        if (!t.terminal)\n            table[t.name] = [];\n    for (;;) {\n        let change = false;\n        for (let nt of terms.terms)\n            if (!nt.terminal)\n                for (let rule of nt.rules) {\n                    let set = table[nt.name];\n                    let found = false, startLen = set.length;\n                    for (let part of rule.parts) {\n                        found = true;\n                        if (part.terminal) {\n                            addTo(part, set);\n                        }\n                        else {\n                            for (let t of table[part.name]) {\n                                if (t == null)\n                                    found = false;\n                                else\n                                    addTo(t, set);\n                            }\n                        }\n                        if (found)\n                            break;\n                    }\n                    if (!found)\n                        addTo(null, set);\n                    if (set.length > startLen)\n                        change = true;\n                }\n        if (!change)\n            return table;\n    }\n}\nclass Core {\n    constructor(set, state) {\n        this.set = set;\n        this.state = state;\n    }\n}\nclass Conflict {\n    constructor(error, rules) {\n        this.error = error;\n        this.rules = rules;\n    }\n}\nfunction findConflictOrigin(a, b) {\n    if (a.eqSimple(b))\n        return \"\";\n    function via(root, start) {\n        let hist = [];\n        for (let p = start.via; !p.eqSimple(root); p = p.via)\n            hist.push(p);\n        if (!hist.length)\n            return \"\";\n        hist.unshift(start);\n        return hist.reverse().map((p, i) => \"\\n\" + \"  \".repeat(i + 1) + (p == start ? \"\" : \"via \") + p).join(\"\");\n    }\n    for (let p = a; p; p = p.via)\n        for (let p2 = b; p2; p2 = p2.via) {\n            if (p.eqSimple(p2))\n                return \"\\nShared origin: \" + p + via(p, a) + via(p, b);\n        }\n    return \"\";\n}\n// Search for the reason that a given 'after' token exists at the\n// given pos, by scanning up the trail of positions. Because the `via`\n// link is only one source of a pos, of potentially many, this\n// requires a re-simulation of the whole path up to the pos.\nfunction findConflictShiftSource(conflictPos, termAfter, first) {\n    let pos = conflictPos, path = [];\n    for (;;) {\n        for (let i = pos.pos - 1; i >= 0; i--)\n            path.push(pos.rule.parts[i]);\n        if (!pos.via)\n            break;\n        pos = pos.via;\n    }\n    path.reverse();\n    let seen = new Set();\n    function explore(pos, i, hasMatch) {\n        if (i == path.length && hasMatch && !pos.next)\n            return `\\nThe reduction of ${conflictPos.rule.name} is allowed before ${termAfter} because of this rule:\\n  ${hasMatch}`;\n        for (let next; next = pos.next;) {\n            if (i < path.length && next == path[i]) {\n                let inner = explore(pos.advance(), i + 1, hasMatch);\n                if (inner)\n                    return inner;\n            }\n            let after = pos.rule.parts[pos.pos + 1], match = pos.pos + 1 == pos.rule.parts.length ? hasMatch : null;\n            if (after && (after.terminal ? after == termAfter : first[after.name].includes(termAfter)))\n                match = pos.advance();\n            for (let rule of next.rules) {\n                let hash = (rule.id << 5) + i + (match ? 555 : 0);\n                if (!seen.has(hash)) {\n                    seen.add(hash);\n                    let inner = explore(new Pos(rule, 0, [], [], next, pos), i, match);\n                    if (inner)\n                        return inner;\n                }\n            }\n            if (!next.terminal && first[next.name].includes(null))\n                pos = pos.advance();\n            else\n                break;\n        }\n        return \"\";\n    }\n    return explore(pos, 0, null);\n}\n// Builds a full LR(1) automaton\nfunction buildFullAutomaton(terms, startTerms, first) {\n    let states = [], statesBySetHash = {};\n    let cores = {};\n    let t0 = Date.now();\n    function getState(core, top) {\n        if (core.length == 0)\n            return null;\n        let coreHash = hashPositions(core), byHash = cores[coreHash];\n        let skip;\n        for (let pos of core) {\n            if (!skip)\n                skip = pos.skip;\n            else if (skip != pos.skip)\n                throw new GenError(\"Inconsistent skip sets after \" + pos.trail());\n        }\n        if (byHash)\n            for (let known of byHash)\n                if (eqSet(core, known.set)) {\n                    if (known.state.skip != skip)\n                        throw new GenError(\"Inconsistent skip sets after \" + known.set[0].trail());\n                    return known.state;\n                }\n        let set = closure(core, first);\n        let hash = hashPositions(set), forHash = statesBySetHash[hash] || (statesBySetHash[hash] = []);\n        let found;\n        if (!top)\n            for (let state of forHash)\n                if (state.hasSet(set))\n                    found = state;\n        if (!found) {\n            found = new State(states.length, set, 0, skip, hash, top);\n            forHash.push(found);\n            states.push(found);\n            if (timing && states.length % 500 == 0)\n                console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);\n        }\n        (cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));\n        return found;\n    }\n    for (const startTerm of startTerms) {\n        const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[\"%noskip\"];\n        getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);\n    }\n    let conflicts = new ConflictContext(first);\n    for (let filled = 0; filled < states.length; filled++) {\n        let state = states[filled];\n        let byTerm = [], byTermPos = [], atEnd = [];\n        for (let pos of state.set) {\n            if (pos.pos == pos.rule.parts.length) {\n                if (!pos.rule.name.top)\n                    atEnd.push(pos);\n            }\n            else {\n                let next = pos.rule.parts[pos.pos];\n                let index = byTerm.indexOf(next);\n                if (index < 0) {\n                    byTerm.push(next);\n                    byTermPos.push([pos]);\n                }\n                else {\n                    byTermPos[index].push(pos);\n                }\n            }\n        }\n        for (let i = 0; i < byTerm.length; i++) {\n            let term = byTerm[i], positions = byTermPos[i].map(p => p.advance());\n            if (term.terminal) {\n                let set = applyCut(positions);\n                let next = getState(set);\n                if (next)\n                    state.addAction(new Shift(term, next), byTermPos[i], conflicts);\n            }\n            else {\n                let goto = getState(positions);\n                if (goto)\n                    state.goto.push(new Shift(term, goto));\n            }\n        }\n        let replaced = false;\n        for (let pos of atEnd)\n            for (let ahead of pos.ahead) {\n                let count = state.actions.length;\n                state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);\n                if (state.actions.length == count)\n                    replaced = true;\n            }\n        // If some actions were replaced by others, double-check whether\n        // goto entries are now superfluous (for example, in an operator\n        // precedence-related state that has a shift for `*` but only a\n        // reduce for `+`, we don't need a goto entry for rules that start\n        // with `+`)\n        if (replaced)\n            for (let i = 0; i < state.goto.length; i++) {\n                let start = first[state.goto[i].term.name];\n                if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))\n                    state.goto.splice(i--, 1);\n            }\n    }\n    if (conflicts.conflicts.length)\n        throw new GenError(conflicts.conflicts.map(c => c.error).join(\"\\n\\n\"));\n    // Resolve alwaysReduce and sort actions\n    for (let state of states)\n        state.finish();\n    if (timing)\n        console.log(`${states.length} states total.`);\n    return states;\n}\nfunction applyCut(set) {\n    let found = null, cut = 1;\n    for (let pos of set) {\n        let value = pos.rule.conflicts[pos.pos - 1].cut;\n        if (value < cut)\n            continue;\n        if (!found || value > cut) {\n            cut = value;\n            found = [];\n        }\n        found.push(pos);\n    }\n    return found || set;\n}\n// Verify that there are no conflicting actions or goto entries in the\n// two given states (using the state ID remapping provided in mapping)\nfunction canMerge(a, b, mapping) {\n    // If a goto for the same term differs, that makes the states\n    // incompatible\n    for (let goto of a.goto)\n        for (let other of b.goto) {\n            if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id])\n                return false;\n        }\n    // If there is an action where a conflicting action exists in the\n    // other state, the merge is only allowed when both states have the\n    // exact same set of actions for this term.\n    let byTerm = b.actionsByTerm();\n    for (let action of a.actions) {\n        let setB = byTerm[action.term.id];\n        if (setB && setB.some(other => !other.matches(action, mapping))) {\n            if (setB.length == 1)\n                return false;\n            let setA = a.actionsByTerm()[action.term.id];\n            if (setA.length != setB.length || setA.some(a1 => !setB.some(a2 => a1.matches(a2, mapping))))\n                return false;\n        }\n    }\n    return true;\n}\nfunction mergeStates(states, mapping) {\n    let newStates = [];\n    for (let state of states) {\n        let newID = mapping[state.id];\n        if (!newStates[newID]) {\n            newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);\n            newStates[newID].tokenGroup = state.tokenGroup;\n            newStates[newID].defaultReduce = state.defaultReduce;\n        }\n    }\n    for (let state of states) {\n        let newID = mapping[state.id], target = newStates[newID];\n        target.flags |= state.flags;\n        for (let i = 0; i < state.actions.length; i++) {\n            let action = state.actions[i].map(mapping, newStates);\n            if (!target.actions.some(a => a.eq(action))) {\n                target.actions.push(action);\n                target.actionPositions.push(state.actionPositions[i]);\n            }\n        }\n        for (let goto of state.goto) {\n            let mapped = goto.map(mapping, newStates);\n            if (!target.goto.some(g => g.eq(mapped)))\n                target.goto.push(mapped);\n        }\n    }\n    return newStates;\n}\nclass Group {\n    constructor(origin, member) {\n        this.origin = origin;\n        this.members = [member];\n    }\n}\nfunction samePosSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eqSimple(b[i]))\n            return false;\n    return true;\n}\n// Collapse an LR(1) automaton to an LALR-like automaton\nfunction collapseAutomaton(states) {\n    let mapping = [], groups = [];\n    assignGroups: for (let i = 0; i < states.length; i++) {\n        let state = states[i];\n        if (!state.startRule)\n            for (let j = 0; j < groups.length; j++) {\n                let group = groups[j], other = states[group.members[0]];\n                if (state.tokenGroup == other.tokenGroup &&\n                    state.skip == other.skip &&\n                    !other.startRule &&\n                    samePosSet(state.set, other.set)) {\n                    group.members.push(i);\n                    mapping.push(j);\n                    continue assignGroups;\n                }\n            }\n        mapping.push(groups.length);\n        groups.push(new Group(groups.length, i));\n    }\n    function spill(groupIndex, index) {\n        let group = groups[groupIndex], state = states[group.members[index]];\n        let pop = group.members.pop();\n        if (index != group.members.length)\n            group.members[index] = pop;\n        for (let i = groupIndex + 1; i < groups.length; i++) {\n            mapping[state.id] = i;\n            if (groups[i].origin == group.origin &&\n                groups[i].members.every(id => canMerge(state, states[id], mapping))) {\n                groups[i].members.push(state.id);\n                return;\n            }\n        }\n        mapping[state.id] = groups.length;\n        groups.push(new Group(group.origin, state.id));\n    }\n    for (let pass = 1;; pass++) {\n        let conflicts = false, t0 = Date.now();\n        for (let g = 0, startLen = groups.length; g < startLen; g++) {\n            let group = groups[g];\n            for (let i = 0; i < group.members.length - 1; i++) {\n                for (let j = i + 1; j < group.members.length; j++) {\n                    let idA = group.members[i], idB = group.members[j];\n                    if (!canMerge(states[idA], states[idB], mapping)) {\n                        conflicts = true;\n                        spill(g, j--);\n                    }\n                }\n            }\n        }\n        if (timing)\n            console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!conflicts)\n            return mergeStates(states, mapping);\n    }\n}\nfunction mergeIdentical(states) {\n    for (let pass = 1;; pass++) {\n        let mapping = [], didMerge = false, t0 = Date.now();\n        let newStates = [];\n        // Find states that either have the same alwaysReduce or the same\n        // actions, and merge them.\n        for (let i = 0; i < states.length; i++) {\n            let state = states[i];\n            let match = newStates.findIndex(s => state.eq(s));\n            if (match < 0) {\n                mapping[i] = newStates.length;\n                newStates.push(state);\n            }\n            else {\n                mapping[i] = match;\n                didMerge = true;\n                let other = newStates[match], add = null;\n                for (let pos of state.set)\n                    if (!other.set.some(p => p.eqSimple(pos)))\n                        (add || (add = [])).push(pos);\n                if (add)\n                    other.set = add.concat(other.set).sort((a, b) => a.cmp(b));\n            }\n        }\n        if (timing)\n            console.log(`Merge identical pass ${pass}${didMerge ? \"\" : \", done\"} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!didMerge)\n            return states;\n        // Make sure actions point at merged state objects\n        for (let state of newStates)\n            if (!state.defaultReduce) {\n                state.actions = state.actions.map(a => a.map(mapping, newStates));\n                state.goto = state.goto.map(a => a.map(mapping, newStates));\n            }\n        // Renumber ids\n        for (let i = 0; i < newStates.length; i++)\n            newStates[i].id = i;\n        states = newStates;\n    }\n}\nconst none$1 = [];\nfunction finishAutomaton(full) {\n    return mergeIdentical(collapseAutomaton(full));\n}\n\n// Encode numbers as groups of printable ascii characters\n//\n// - 0xffff, which is often used as placeholder, is encoded as \"~\"\n//\n// - The characters from \" \" (32) to \"}\" (125), excluding '\"' and\n//   \"\\\\\", indicate values from 0 to 92\n//\n// - The first bit in a 'digit' is used to indicate whether this is\n//   the end of a number.\n//\n// - That leaves 46 other values, which are actually significant.\n//\n// - The digits in a number are ordered from high to low significance.\nfunction digitToChar(digit) {\n    let ch = digit + 32 /* Encode.Start */;\n    if (ch >= 34 /* Encode.Gap1 */)\n        ch++;\n    if (ch >= 92 /* Encode.Gap2 */)\n        ch++;\n    return String.fromCharCode(ch);\n}\nfunction encode(value, max = 0xffff) {\n    if (value > max)\n        throw new Error(\"Trying to encode a number that's too big: \" + value);\n    if (value == 65535 /* Encode.BigVal */)\n        return String.fromCharCode(126 /* Encode.BigValCode */);\n    let result = \"\";\n    for (let first = 46 /* Encode.Base */;; first = 0) {\n        let low = value % 46 /* Encode.Base */, rest = value - low;\n        result = digitToChar(low + first) + result;\n        if (rest == 0)\n            break;\n        value = rest / 46 /* Encode.Base */;\n    }\n    return result;\n}\nfunction encodeArray(values, max = 0xffff) {\n    let result = '\"' + encode(values.length, 0xffffffff);\n    for (let i = 0; i < values.length; i++)\n        result += encode(values[i], max);\n    result += '\"';\n    return result;\n}\n\nconst none = [];\nclass Parts {\n    constructor(terms, conflicts) {\n        this.terms = terms;\n        this.conflicts = conflicts;\n    }\n    concat(other) {\n        if (this == Parts.none)\n            return other;\n        if (other == Parts.none)\n            return this;\n        let conflicts = null;\n        if (this.conflicts || other.conflicts) {\n            conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n            let otherConflicts = other.ensureConflicts();\n            conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);\n            for (let i = 1; i < otherConflicts.length; i++)\n                conflicts.push(otherConflicts[i]);\n        }\n        return new Parts(this.terms.concat(other.terms), conflicts);\n    }\n    withConflicts(pos, conflicts) {\n        if (conflicts == Conflicts.none)\n            return this;\n        let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n        array[pos] = array[pos].join(conflicts);\n        return new Parts(this.terms, array);\n    }\n    ensureConflicts() {\n        if (this.conflicts)\n            return this.conflicts;\n        let empty = [];\n        for (let i = 0; i <= this.terms.length; i++)\n            empty.push(Conflicts.none);\n        return empty;\n    }\n}\nParts.none = new Parts(none, null);\nfunction p(...terms) { return new Parts(terms, null); }\nclass BuiltRule {\n    constructor(id, args, term) {\n        this.id = id;\n        this.args = args;\n        this.term = term;\n    }\n    matches(expr) {\n        return this.id == expr.id.name && exprsEq(expr.args, this.args);\n    }\n    matchesRepeat(expr) {\n        return this.id == \"+\" && exprEq(expr.expr, this.args[0]);\n    }\n}\nclass Builder {\n    constructor(text, options) {\n        this.options = options;\n        this.terms = new TermSet;\n        this.specialized = Object.create(null);\n        this.tokenOrigins = Object.create(null);\n        this.rules = [];\n        this.built = [];\n        this.ruleNames = Object.create(null);\n        this.namespaces = Object.create(null);\n        this.namedTerms = Object.create(null);\n        this.termTable = Object.create(null);\n        this.knownProps = Object.create(null);\n        this.dynamicRulePrecedences = [];\n        this.definedGroups = [];\n        this.astRules = [];\n        this.currentSkip = [];\n        time(\"Parse\", () => {\n            this.input = new Input(text, options.fileName);\n            this.ast = this.input.parse();\n        });\n        let NP = NodeProp;\n        for (let prop in NP) {\n            if (NP[prop] instanceof NodeProp && !NP[prop].perNode)\n                this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };\n        }\n        for (let prop of this.ast.externalProps) {\n            this.knownProps[prop.id.name] = {\n                prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new NodeProp(),\n                source: { name: prop.externalID.name, from: prop.source }\n            };\n        }\n        this.dialects = this.ast.dialects.map(d => d.name);\n        this.tokens = new MainTokenSet(this, this.ast.tokens);\n        this.localTokens = this.ast.localTokens.map(g => new LocalTokenSet(this, g));\n        this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext));\n        this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl));\n        time(\"Build rules\", () => {\n            let noSkip = this.newName(\"%noskip\", true);\n            this.defineRule(noSkip, []);\n            let mainSkip = this.ast.mainSkip ? this.newName(\"%mainskip\", true) : noSkip;\n            let scopedSkip = [], topRules = [];\n            for (let rule of this.ast.rules)\n                this.astRules.push({ skip: mainSkip, rule });\n            for (let rule of this.ast.topRules)\n                topRules.push({ skip: mainSkip, rule });\n            for (let scoped of this.ast.scopedSkip) {\n                let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr));\n                if (found > -1)\n                    skip = scopedSkip[found];\n                else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip))\n                    skip = mainSkip;\n                else if (!isEmpty(scoped.expr))\n                    skip = this.newName(\"%skip\", true);\n                scopedSkip.push(skip);\n                for (let rule of scoped.rules)\n                    this.astRules.push({ skip, rule });\n                for (let rule of scoped.topRules)\n                    topRules.push({ skip, rule });\n            }\n            for (let { rule } of this.astRules) {\n                this.unique(rule.id);\n            }\n            this.currentSkip.push(noSkip);\n            this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];\n            if (mainSkip != noSkip)\n                this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));\n            for (let i = 0; i < this.ast.scopedSkip.length; i++) {\n                let skip = scopedSkip[i];\n                if (!this.skipRules.includes(skip)) {\n                    this.skipRules.push(skip);\n                    if (skip != noSkip)\n                        this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));\n                }\n            }\n            this.currentSkip.pop();\n            for (let { rule, skip } of topRules.sort((a, b) => a.rule.start - b.rule.start)) {\n                this.unique(rule.id);\n                this.used(rule.id.name);\n                this.currentSkip.push(skip);\n                let { name, props } = this.nodeInfo(rule.props, \"a\", rule.id.name, none, none, rule.expr);\n                let term = this.terms.makeTop(name, props);\n                this.namedTerms[name] = term;\n                this.defineRule(term, this.normalizeExpr(rule.expr));\n                this.currentSkip.pop();\n            }\n            for (let ext of this.externalSpecializers)\n                ext.finish();\n            for (let { skip, rule } of this.astRules) {\n                if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {\n                    this.buildRule(rule, [], skip, false);\n                    if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)\n                        this.used(rule.id.name);\n                }\n            }\n        });\n        for (let name in this.ruleNames) {\n            let value = this.ruleNames[name];\n            if (value)\n                this.warn(`Unused rule '${value.name}'`, value.start);\n        }\n        this.tokens.takePrecedences();\n        this.tokens.takeConflicts();\n        for (let lt of this.localTokens)\n            lt.takePrecedences();\n        for (let { name, group, rule } of this.definedGroups)\n            this.defineGroup(name, group, rule);\n        this.checkGroups();\n    }\n    unique(id) {\n        if (id.name in this.ruleNames)\n            this.raise(`Duplicate definition of rule '${id.name}'`, id.start);\n        this.ruleNames[id.name] = id;\n    }\n    used(name) {\n        this.ruleNames[name] = null;\n    }\n    newName(base, nodeName = null, props = {}) {\n        for (let i = nodeName ? 0 : 1;; i++) {\n            let name = i ? `${base}-${i}` : base;\n            if (!this.terms.names[name])\n                return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);\n        }\n    }\n    prepareParser() {\n        let rules = time(\"Simplify rules\", () => simplifyRules(this.rules, [\n            ...this.skipRules,\n            ...this.terms.tops\n        ]));\n        let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);\n        for (let prop in this.namedTerms)\n            this.termTable[prop] = this.namedTerms[prop].id;\n        if (/\\bgrammar\\b/.test(verbose))\n            console.log(rules.join(\"\\n\"));\n        let startTerms = this.terms.tops.slice();\n        let first = computeFirstSets(this.terms);\n        let skipInfo = this.skipRules.map((name, id) => {\n            let skip = [], startTokens = [], rules = [];\n            for (let rule of name.rules) {\n                if (!rule.parts.length)\n                    continue;\n                let start = rule.parts[0];\n                for (let t of start.terminal ? [start] : first[start.name] || [])\n                    if (t && !startTokens.includes(t))\n                        startTokens.push(t);\n                if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))\n                    skip.push(start);\n                else\n                    rules.push(rule);\n            }\n            name.rules = rules;\n            if (rules.length)\n                startTerms.push(name);\n            return { skip, rule: rules.length ? name : null, startTokens, id };\n        });\n        let fullTable = time(\"Build full automaton\", () => buildFullAutomaton(this.terms, startTerms, first));\n        let localTokens = this.localTokens\n            .map((grp, i) => grp.buildLocalGroup(fullTable, skipInfo, i));\n        let { tokenGroups, tokenPrec, tokenData } = time(\"Build token groups\", () => this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));\n        let table = time(\"Finish automaton\", () => finishAutomaton(fullTable));\n        let skipState = findSkipStates(table, this.terms.tops);\n        if (/\\blr\\b/.test(verbose))\n            console.log(table.join(\"\\n\"));\n        let specialized = [];\n        for (let ext of this.externalSpecializers)\n            specialized.push(ext);\n        for (let name in this.specialized)\n            specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });\n        let tokStart = (tokenizer) => {\n            if (tokenizer instanceof ExternalTokenSet)\n                return tokenizer.ast.start;\n            return this.tokens.ast ? this.tokens.ast.start : -1;\n        };\n        let tokenizers = tokenGroups\n            .concat(this.externalTokens)\n            .sort((a, b) => tokStart(a) - tokStart(b))\n            .concat(localTokens);\n        let data = new DataBuilder;\n        let skipData = skipInfo.map(info => {\n            let actions = [];\n            for (let term of info.skip)\n                actions.push(term.id, 0, 262144 /* Action.StayFlag */ >> 16);\n            if (info.rule) {\n                let state = table.find(s => s.startRule == info.rule);\n                for (let action of state.actions)\n                    actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ >> 16);\n            }\n            actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);\n            return data.storeArray(actions);\n        });\n        let states = time(\"Finish states\", () => {\n            let states = new Uint32Array(table.length * 6 /* ParseState.Size */);\n            let forceReductions = this.computeForceReductions(table, skipInfo);\n            let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);\n            for (let s of table)\n                finishCx.finish(s, skipState(s.id), forceReductions[s.id]);\n            return states;\n        });\n        let dialects = Object.create(null);\n        for (let i = 0; i < this.dialects.length; i++)\n            dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(65535 /* Seq.End */));\n        let dynamicPrecedences = null;\n        if (this.dynamicRulePrecedences.length) {\n            dynamicPrecedences = Object.create(null);\n            for (let { rule, prec } of this.dynamicRulePrecedences)\n                dynamicPrecedences[rule.id] = prec;\n        }\n        let topRules = Object.create(null);\n        for (let term of this.terms.tops)\n            topRules[term.nodeName] = [table.find(state => state.startRule == term).id, term.id];\n        let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));\n        let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);\n        return {\n            states,\n            stateData: data.finish(),\n            goto: computeGotoTable(table),\n            nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(\" \"),\n            nodeProps,\n            skippedTypes,\n            maxTerm,\n            repeatNodeCount: nodeTypes.length - minRepeatTerm,\n            tokenizers,\n            tokenData,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec: precTable,\n            termNames\n        };\n    }\n    getParser() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);\n                return {\n                    term: v.term.id,\n                    get: (value, stack) => (ext(value, stack) << 1) |\n                        (v.ast.type == \"extend\" ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),\n                    external: ext,\n                    extend: v.ast.type == \"extend\"\n                };\n            }\n            else {\n                return { term: v.token.id, get: (value) => v.table[value] || -1 };\n            }\n        });\n        return LRParser.deserialize({\n            version: 14 /* File.Version */,\n            states,\n            stateData,\n            goto,\n            nodeNames,\n            maxTerm,\n            repeatNodeCount,\n            nodeProps: rawNodeProps.map(({ prop, terms }) => [this.knownProps[prop].prop, ...terms]),\n            propSources: !this.options.externalPropSource ? undefined\n                : this.ast.externalPropSources.map(s => this.options.externalPropSource(s.id.name)),\n            skippedNodes: skippedTypes,\n            tokenData,\n            tokenizers: tokenizers.map(tok => tok.create()),\n            context: !this.ast.context ? undefined\n                : typeof this.options.contextTracker == \"function\" ? this.options.contextTracker(this.termTable)\n                    : this.options.contextTracker,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec,\n            termNames\n        });\n    }\n    getParserFile() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let mod = this.options.moduleStyle || \"es\";\n        let gen = \"// This file was generated by lezer-generator. You probably shouldn't edit it.\\n\", head = gen;\n        let imports = {}, imported = Object.create(null);\n        let defined = Object.create(null);\n        for (let word of KEYWORDS)\n            defined[word] = true;\n        let exportName = this.options.exportName || \"parser\";\n        defined[exportName] = true;\n        let getName = (prefix) => {\n            for (let i = 0;; i++) {\n                let id = prefix + (i ? \"_\" + i : \"\");\n                if (!defined[id])\n                    return id;\n            }\n        };\n        let importName = (name, source, prefix = name) => {\n            let spec = name + \" from \" + source;\n            if (imported[spec])\n                return imported[spec];\n            let src = JSON.stringify(source), varName = name;\n            if (name in defined) {\n                varName = getName(prefix);\n                name += `${mod == \"cjs\" ? \":\" : \" as\"} ${varName}`;\n            }\n            defined[varName] = true;\n            (imports[src] || (imports[src] = [])).push(name);\n            return imported[spec] = varName;\n        };\n        let lrParser = importName(\"LRParser\", \"@lezer/lr\");\n        let tokenizers = rawTokenizers.map(tok => tok.createSource(importName));\n        let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;\n        let nodeProps = rawNodeProps.map(({ prop, terms }) => {\n            let { source } = this.knownProps[prop];\n            let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);\n            return `[${propID}, ${terms.map(serializePropValue).join(\",\")}]`;\n        });\n        function specializationTableString(table) {\n            return \"{__proto__:null,\" + Object.keys(table).map(key => `${/^(\\d+|[a-zA-Z_]\\w*)$/.test(key) ? key : JSON.stringify(key)}:${table[key]}`)\n                .join(\", \") + \"}\";\n        }\n        let specHead = \"\";\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let name = importName(v.ast.id.name, v.ast.source);\n                let ts = this.options.typeScript ? \": any\" : \"\";\n                return `{term: ${v.term.id}, get: (value${ts}, stack${ts}) => (${name}(value, stack) << 1)${v.ast.type == \"extend\" ? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == \"extend\" ? ', extend: true' : ''}}`;\n            }\n            else {\n                let tableName = getName(\"spec_\" + v.token.name.replace(/\\W/g, \"\"));\n                defined[tableName] = true;\n                specHead += `const ${tableName} = ${specializationTableString(v.table)}\\n`;\n                let ts = this.options.typeScript ? `: keyof typeof ${tableName}` : \"\";\n                return `{term: ${v.token.id}, get: (value${ts}) => ${tableName}[value] || -1}`;\n            }\n        });\n        let propSources = this.ast.externalPropSources.map(s => importName(s.id.name, s.source));\n        for (let source in imports) {\n            if (mod == \"cjs\")\n                head += `const {${imports[source].join(\", \")}} = require(${source})\\n`;\n            else\n                head += `import {${imports[source].join(\", \")}} from ${source}\\n`;\n        }\n        head += specHead;\n        function serializePropValue(value) {\n            return typeof value != \"string\" || /^(true|false|\\d+(\\.\\d+)?|\\.\\d+)$/.test(value) ? value : JSON.stringify(value);\n        }\n        let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`);\n        let parserStr = `${lrParser}.deserialize({\n  version: ${14 /* File.Version */},\n  states: ${encodeArray(states, 0xffffffff)},\n  stateData: ${encodeArray(stateData)},\n  goto: ${encodeArray(goto)},\n  nodeNames: ${JSON.stringify(nodeNames)},\n  maxTerm: ${maxTerm}${context ? `,\n  context: ${context}` : \"\"}${nodeProps.length ? `,\n  nodeProps: [\n    ${nodeProps.join(\",\\n    \")}\n  ]` : \"\"}${propSources.length ? `,\n  propSources: [${propSources.join()}]` : \"\"}${skippedTypes.length ? `,\n  skippedNodes: ${JSON.stringify(skippedTypes)}` : \"\"},\n  repeatNodeCount: ${repeatNodeCount},\n  tokenData: ${encodeArray(tokenData)},\n  tokenizers: [${tokenizers.join(\", \")}],\n  topRules: ${JSON.stringify(topRules)}${dialects.length ? `,\n  dialects: {${dialects.join(\", \")}}` : \"\"}${dynamicPrecedences ? `,\n  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : \"\"}${specialized.length ? `,\n  specialized: [${specialized.join(\",\")}]` : \"\"},\n  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,\n  termNames: ${JSON.stringify(termNames)}` : ''}\n})`;\n        let terms = [];\n        for (let name in this.termTable) {\n            let id = name;\n            if (KEYWORDS.includes(id))\n                for (let i = 1;; i++) {\n                    id = \"_\".repeat(i) + name;\n                    if (!(id in this.termTable))\n                        break;\n                }\n            else if (!/^[\\w$]+$/.test(name)) {\n                continue;\n            }\n            terms.push(`${id}${mod == \"cjs\" ? \":\" : \" =\"} ${this.termTable[name]}`);\n        }\n        for (let id = 0; id < this.dialects.length; id++)\n            terms.push(`Dialect_${this.dialects[id]}${mod == \"cjs\" ? \":\" : \" =\"} ${id}`);\n        return {\n            parser: head + (mod == \"cjs\" ? `exports.${exportName} = ${parserStr}\\n` : `export const ${exportName} = ${parserStr}\\n`),\n            terms: mod == \"cjs\" ? `${gen}module.exports = {\\n  ${terms.join(\",\\n  \")}\\n}`\n                : `${gen}export const\\n  ${terms.join(\",\\n  \")}\\n`\n        };\n    }\n    gatherNonSkippedNodes() {\n        let seen = Object.create(null);\n        let work = [];\n        let add = (term) => {\n            if (!seen[term.id]) {\n                seen[term.id] = true;\n                work.push(term);\n            }\n        };\n        this.terms.tops.forEach(add);\n        for (let i = 0; i < work.length; i++) {\n            for (let rule of work[i].rules)\n                for (let part of rule.parts)\n                    add(part);\n        }\n        return seen;\n    }\n    gatherNodeProps(nodeTypes) {\n        let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];\n        let nodeProps = [];\n        for (let type of nodeTypes) {\n            if (!notSkipped[type.id] && !type.error)\n                skippedTypes.push(type.id);\n            for (let prop in type.props) {\n                let known = this.knownProps[prop];\n                if (!known)\n                    throw new GenError(\"No known prop type for \" + prop);\n                if (known.source.from == null && (known.source.name == \"repeated\" || known.source.name == \"error\"))\n                    continue;\n                let rec = nodeProps.find(r => r.prop == prop);\n                if (!rec)\n                    nodeProps.push(rec = { prop, values: {} });\n                (rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);\n            }\n        }\n        return {\n            nodeProps: nodeProps.map(({ prop, values }) => {\n                let terms = [];\n                for (let val in values) {\n                    let ids = values[val];\n                    if (ids.length == 1) {\n                        terms.push(ids[0], val);\n                    }\n                    else {\n                        terms.push(-ids.length);\n                        for (let id of ids)\n                            terms.push(id);\n                        terms.push(val);\n                    }\n                }\n                return { prop, terms };\n            }),\n            skippedTypes\n        };\n    }\n    makeTerminal(name, tag, props) {\n        return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);\n    }\n    computeForceReductions(states, skipInfo) {\n        // This finds a forced reduction for every state, trying to guard\n        // against cyclic forced reductions, where a given parse stack can\n        // endlessly continue running forced reductions without making any\n        // progress.\n        //\n        // This occurs with length-1 reductions. We never generate\n        // length-0 reductions, and length-2+ reductions always shrink the\n        // stack, so they are guaranteed to make progress.\n        //\n        // If there are states S1 and S2 whose forced reductions reduce\n        // terms T1 and T2 respectively, both with a length of 1, _and_\n        // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,\n        // you can get cyclic reductions. Of course, the cycle may also\n        // contain more than two steps.\n        let reductions = [];\n        let candidates = [];\n        // A map from terms to states that they are mapped to in goto\n        // entries.\n        let gotoEdges = Object.create(null);\n        for (let state of states) {\n            reductions.push(0);\n            for (let edge of state.goto) {\n                let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);\n                let found = array.find(o => o.target == edge.target.id);\n                if (found)\n                    found.parents.push(state.id);\n                else\n                    array.push({ parents: [state.id], target: edge.target.id });\n            }\n            candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)\n                .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);\n        }\n        // Mapping from state ids to terms that that state has a length-1\n        // forced reduction for.\n        let length1Reductions = Object.create(null);\n        function createsCycle(term, startState, parents = null) {\n            let edges = gotoEdges[term];\n            if (!edges)\n                return false;\n            return edges.some(val => {\n                let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents;\n                if (parentIntersection.length == 0)\n                    return false;\n                if (val.target == startState)\n                    return true;\n                let found = length1Reductions[val.target];\n                return found != null && createsCycle(found, startState, parentIntersection);\n            });\n        }\n        for (let state of states) {\n            if (state.defaultReduce && state.defaultReduce.parts.length > 0) {\n                reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);\n                if (state.defaultReduce.parts.length == 1)\n                    length1Reductions[state.id] = state.defaultReduce.name.id;\n            }\n        }\n        // To avoid painting states that only have one potential forced\n        // reduction into a corner, reduction assignment is done by\n        // candidate size, starting with the states with fewer candidates.\n        for (let setSize = 1;; setSize++) {\n            let done = true;\n            for (let state of states) {\n                if (state.defaultReduce)\n                    continue;\n                let set = candidates[state.id];\n                if (set.length != setSize) {\n                    if (set.length > setSize)\n                        done = false;\n                    continue;\n                }\n                for (let pos of set) {\n                    if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {\n                        reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);\n                        if (pos.pos == 1)\n                            length1Reductions[state.id] = pos.rule.name.id;\n                        break;\n                    }\n                }\n            }\n            if (done)\n                break;\n        }\n        return reductions;\n    }\n    substituteArgs(expr, args, params) {\n        if (args.length == 0)\n            return expr;\n        return expr.walk(expr => {\n            let found;\n            if (expr instanceof NameExpression &&\n                (found = params.findIndex(p => p.name == expr.id.name)) > -1) {\n                let arg = args[found];\n                if (expr.args.length) {\n                    if (arg instanceof NameExpression && !arg.args.length)\n                        return new NameExpression(expr.start, arg.id, expr.args);\n                    this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);\n                }\n                return arg;\n            }\n            else if (expr instanceof InlineRuleExpression) {\n                let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);\n                return props == r.props ? expr :\n                    new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));\n            }\n            else if (expr instanceof SpecializeExpression) {\n                let props = this.substituteArgsInProps(expr.props, args, params);\n                return props == expr.props ? expr :\n                    new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);\n            }\n            return expr;\n        });\n    }\n    substituteArgsInProps(props, args, params) {\n        let substituteInValue = (value) => {\n            let result = value;\n            for (let i = 0; i < value.length; i++) {\n                let part = value[i];\n                if (!part.name)\n                    continue;\n                let found = params.findIndex(p => p.name == part.name);\n                if (found < 0)\n                    continue;\n                if (result == value)\n                    result = value.slice();\n                let expr = args[found];\n                if (expr instanceof NameExpression && !expr.args.length)\n                    result[i] = new PropPart(part.start, expr.id.name, null);\n                else if (expr instanceof LiteralExpression)\n                    result[i] = new PropPart(part.start, expr.value, null);\n                else\n                    this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);\n            }\n            return result;\n        };\n        let result = props;\n        for (let i = 0; i < props.length; i++) {\n            let prop = props[i], value = substituteInValue(prop.value);\n            if (value != prop.value) {\n                if (result == props)\n                    result = props.slice();\n                result[i] = new Prop(prop.start, prop.at, prop.name, value);\n            }\n        }\n        return result;\n    }\n    conflictsFor(markers) {\n        let here = Conflicts.none, atEnd = Conflicts.none;\n        for (let marker of markers) {\n            if (marker.type == \"ambig\") {\n                here = here.join(new Conflicts(0, [marker.id.name]));\n            }\n            else {\n                let precs = this.ast.precedences;\n                let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1;\n                if (index < 0)\n                    this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);\n                let prec = precs.items[index], value = precs.items.length - index;\n                if (prec.type == \"cut\") {\n                    here = here.join(new Conflicts(0, none, value));\n                }\n                else {\n                    here = here.join(new Conflicts(value << 2));\n                    atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == \"left\" ? 1 : prec.type == \"right\" ? -1 : 0)));\n                }\n            }\n        }\n        return { here, atEnd };\n    }\n    raise(message, pos = 1) {\n        return this.input.raise(message, pos);\n    }\n    warn(message, pos = -1) {\n        let msg = this.input.message(message, pos);\n        if (this.options.warn)\n            this.options.warn(msg);\n        else\n            console.warn(msg);\n    }\n    defineRule(name, choices) {\n        let skip = this.currentSkip[this.currentSkip.length - 1];\n        for (let choice of choices)\n            this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));\n    }\n    resolve(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return [p(built.term)];\n        let found = this.tokens.getToken(expr);\n        if (found)\n            return [p(found)];\n        for (let grp of this.localTokens) {\n            let found = grp.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalTokens) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalSpecializers) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        let known = this.astRules.find(r => r.rule.id.name == expr.id.name);\n        if (!known)\n            return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);\n        if (known.rule.params.length != expr.args.length)\n            this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);\n        this.used(known.rule.id.name);\n        return [p(this.buildRule(known.rule, expr.args, known.skip))];\n    }\n    // For tree-balancing reasons, repeat expressions X+ have to be\n    // normalized to something like\n    //\n    //     R -> X | R R\n    //\n    // Returns the `R` term.\n    normalizeRepeat(expr) {\n        let known = this.built.find(b => b.matchesRepeat(expr));\n        if (known)\n            return p(known.term);\n        let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;\n        let term = this.terms.makeRepeat(this.terms.uniqueName(name));\n        this.built.push(new BuiltRule(\"+\", [expr.expr], term));\n        this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));\n        return p(term);\n    }\n    normalizeSequence(expr) {\n        let result = expr.exprs.map(e => this.normalizeExpr(e));\n        let builder = this;\n        function complete(start, from, endConflicts) {\n            let { here, atEnd } = builder.conflictsFor(expr.markers[from]);\n            if (from == result.length)\n                return [start.withConflicts(start.terms.length, here.join(endConflicts))];\n            let choices = [];\n            for (let choice of result[from]) {\n                for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))\n                    choices.push(full);\n            }\n            return choices;\n        }\n        return complete(Parts.none, 0, Conflicts.none);\n    }\n    normalizeExpr(expr) {\n        if (expr instanceof RepeatExpression && expr.kind == \"?\") {\n            return [Parts.none, ...this.normalizeExpr(expr.expr)];\n        }\n        else if (expr instanceof RepeatExpression) {\n            let repeated = this.normalizeRepeat(expr);\n            return expr.kind == \"+\" ? [repeated] : [Parts.none, repeated];\n        }\n        else if (expr instanceof ChoiceExpression) {\n            return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), []);\n        }\n        else if (expr instanceof SequenceExpression) {\n            return this.normalizeSequence(expr);\n        }\n        else if (expr instanceof LiteralExpression) {\n            return [p(this.tokens.getLiteral(expr))];\n        }\n        else if (expr instanceof NameExpression) {\n            return this.resolve(expr);\n        }\n        else if (expr instanceof SpecializeExpression) {\n            return [p(this.resolveSpecialization(expr))];\n        }\n        else if (expr instanceof InlineRuleExpression) {\n            return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];\n        }\n        else {\n            return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);\n        }\n    }\n    buildRule(rule, args, skip, inline = false) {\n        let expr = this.substituteArgs(rule.expr, args, rule.params);\n        let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? \"pg\" : \"pgi\", rule.id.name, args, rule.params, rule.expr);\n        if (exported && rule.params.length)\n            this.warn(`Can't export parameterized rules`, rule.start);\n        if (exported && inline)\n            this.warn(`Can't export inline rule`, rule.start);\n        let name = this.newName(rule.id.name + (args.length ? \"<\" + args.join(\",\") + \">\" : \"\"), nodeName || true, props);\n        if (explicitInline)\n            name.inline = true;\n        if (dynamicPrec)\n            this.registerDynamicPrec(name, dynamicPrec);\n        if ((name.nodeType || exported) && rule.params.length == 0) {\n            if (!nodeName)\n                name.preserve = true;\n            if (!inline)\n                this.namedTerms[exported || rule.id.name] = name;\n        }\n        if (!inline)\n            this.built.push(new BuiltRule(rule.id.name, args, name));\n        this.currentSkip.push(skip);\n        let parts = this.normalizeExpr(expr);\n        if (parts.length > 100 * (expr instanceof ChoiceExpression ? expr.exprs.length : 1))\n            this.warn(`Rule ${rule.id.name} is generating a lot (${parts.length}) of choices.\\n  Consider splitting it up or reducing the amount of ? or | operator uses.`, rule.start);\n        if (/\\brulesize\\b/.test(verbose) && parts.length > 10)\n            console.log(`Rule ${rule.id.name}: ${parts.length} variants`);\n        this.defineRule(name, parts);\n        this.currentSkip.pop();\n        if (group)\n            this.definedGroups.push({ name, group, rule });\n        return name;\n    }\n    nodeInfo(props, \n    // p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name\n    allow, defaultName = null, args = none, params = none, expr, defaultProps) {\n        let result = {};\n        let name = defaultName && (allow.indexOf(\"a\") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null;\n        let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;\n        for (let prop of props) {\n            if (!prop.at) {\n                if (!this.knownProps[prop.name]) {\n                    let builtin = [\"name\", \"dialect\", \"dynamicPrecedence\", \"export\", \"isGroup\"].includes(prop.name)\n                        ? ` (did you mean '@${prop.name}'?)` : \"\";\n                    this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);\n                }\n                result[prop.name] = this.finishProp(prop, args, params);\n            }\n            else if (prop.name == \"name\") {\n                name = this.finishProp(prop, args, params);\n                if (/ /.test(name))\n                    this.raise(`Node names cannot have spaces ('${name}')`, prop.start);\n            }\n            else if (prop.name == \"dialect\") {\n                if (allow.indexOf(\"d\") < 0)\n                    this.raise(\"Can't specify a dialect on non-token rules\", props[0].start);\n                if (prop.value.length != 1 && !prop.value[0].value)\n                    this.raise(\"The '@dialect' rule prop must hold a plain string value\");\n                let dialectID = this.dialects.indexOf(prop.value[0].value);\n                if (dialectID < 0)\n                    this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);\n                dialect = dialectID;\n            }\n            else if (prop.name == \"dynamicPrecedence\") {\n                if (allow.indexOf(\"p\") < 0)\n                    this.raise(\"Dynamic precedence can only be specified on nonterminals\");\n                if (prop.value.length != 1 || !/^-?(?:10|\\d)$/.test(prop.value[0].value))\n                    this.raise(\"The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10\");\n                dynamicPrec = +prop.value[0].value;\n            }\n            else if (prop.name == \"inline\") {\n                if (prop.value.length)\n                    this.raise(\"'@inline' doesn't take a value\", prop.value[0].start);\n                if (allow.indexOf(\"i\") < 0)\n                    this.raise(\"Inline can only be specified on nonterminals\");\n                inline = true;\n            }\n            else if (prop.name == \"isGroup\") {\n                if (allow.indexOf(\"g\") < 0)\n                    this.raise(\"'@isGroup' can only be specified on nonterminals\");\n                group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;\n            }\n            else if (prop.name == \"export\") {\n                if (prop.value.length)\n                    exported = this.finishProp(prop, args, params);\n                else\n                    exported = defaultName;\n            }\n            else {\n                this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);\n            }\n        }\n        if (expr && this.ast.autoDelim && (name || hasProps(result))) {\n            let delim = this.findDelimiters(expr);\n            if (delim) {\n                addToProp(delim[0], \"closedBy\", delim[1].nodeName);\n                addToProp(delim[1], \"openedBy\", delim[0].nodeName);\n            }\n        }\n        if (defaultProps && hasProps(defaultProps)) {\n            for (let prop in defaultProps)\n                if (!(prop in result))\n                    result[prop] = defaultProps[prop];\n        }\n        if (hasProps(result) && !name)\n            this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);\n        if (inline && (hasProps(result) || dialect || dynamicPrec))\n            this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);\n        if (inline && name)\n            name = null;\n        return { name, props: result, dialect, dynamicPrec, inline, group, exported };\n    }\n    finishProp(prop, args, params) {\n        return prop.value.map(part => {\n            if (part.value)\n                return part.value;\n            let pos = params.findIndex(param => param.name == part.name);\n            if (pos < 0)\n                this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);\n            let expr = args[pos];\n            if (expr instanceof NameExpression && !expr.args.length)\n                return expr.id.name;\n            if (expr instanceof LiteralExpression)\n                return expr.value;\n            return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);\n        }).join(\"\");\n    }\n    resolveSpecialization(expr) {\n        let type = expr.type;\n        let { name, props, dialect, exported } = this.nodeInfo(expr.props, \"d\");\n        let terminal = this.normalizeExpr(expr.token);\n        if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)\n            this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);\n        let values;\n        if (expr.content instanceof LiteralExpression)\n            values = [expr.content.value];\n        else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))\n            values = expr.content.exprs.map(expr => expr.value);\n        else\n            return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);\n        let term = terminal[0].terms[0], token = null;\n        let table = this.specialized[term.name] || (this.specialized[term.name] = []);\n        for (let value of values) {\n            let known = table.find(sp => sp.value == value);\n            if (known == null) {\n                if (!token) {\n                    token = this.makeTerminal(term.name + \"/\" + JSON.stringify(value), name, props);\n                    if (dialect != null)\n                        (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);\n                }\n                table.push({ value, term: token, type, dialect, name });\n                this.tokenOrigins[token.name] = { spec: term };\n                if (name || exported) {\n                    if (!name)\n                        token.preserve = true;\n                    this.namedTerms[exported || name] = token;\n                }\n            }\n            else {\n                if (known.type != type)\n                    this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);\n                if (known.dialect != dialect)\n                    this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (known.name != name)\n                    this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (token && known.term != token)\n                    this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                token = known.term;\n            }\n        }\n        return token;\n    }\n    findDelimiters(expr) {\n        if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2)\n            return null;\n        let findToken = (expr) => {\n            if (expr instanceof LiteralExpression)\n                return { term: this.tokens.getLiteral(expr), str: expr.value };\n            if (expr instanceof NameExpression && expr.args.length == 0) {\n                let rule = this.ast.rules.find(r => r.id.name == expr.id.name);\n                if (rule)\n                    return findToken(rule.expr);\n                let token = this.tokens.rules.find(r => r.id.name == expr.id.name);\n                if (token && token.expr instanceof LiteralExpression)\n                    return { term: this.tokens.getToken(expr), str: token.expr.value };\n            }\n            return null;\n        };\n        let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);\n        if (!lastToken || !lastToken.term.nodeName)\n            return null;\n        const brackets = [\"()\", \"[]\", \"{}\", \"<>\"];\n        let bracket = brackets.find(b => lastToken.str.indexOf(b[1]) > -1 && lastToken.str.indexOf(b[0]) < 0);\n        if (!bracket)\n            return null;\n        let firstToken = findToken(expr.exprs[0]);\n        if (!firstToken || !firstToken.term.nodeName ||\n            firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1)\n            return null;\n        return [firstToken.term, lastToken.term];\n    }\n    registerDynamicPrec(term, prec) {\n        this.dynamicRulePrecedences.push({ rule: term, prec });\n        term.preserve = true;\n    }\n    defineGroup(rule, group, ast) {\n        var _a;\n        let recur = [];\n        let getNamed = (rule) => {\n            if (rule.nodeName)\n                return [rule];\n            if (recur.includes(rule))\n                this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);\n            let result = [];\n            recur.push(rule);\n            for (let r of this.rules)\n                if (r.name == rule) {\n                    let names = r.parts.map(getNamed).filter(x => x.length);\n                    if (names.length > 1)\n                        this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);\n                    if (names.length == 1)\n                        for (let n of names[0])\n                            result.push(n);\n                }\n            recur.pop();\n            return result;\n        };\n        for (let name of getNamed(rule))\n            name.props[\"group\"] = (((_a = name.props[\"group\"]) === null || _a === void 0 ? void 0 : _a.split(\" \")) || []).concat(group).sort().join(\" \");\n    }\n    checkGroups() {\n        let groups = Object.create(null), nodeNames = Object.create(null);\n        for (let term of this.terms.terms)\n            if (term.nodeName) {\n                nodeNames[term.nodeName] = true;\n                if (term.props[\"group\"])\n                    for (let group of term.props[\"group\"].split(\" \")) {\n                        (groups[group] || (groups[group] = [])).push(term);\n                    }\n            }\n        let names = Object.keys(groups);\n        for (let i = 0; i < names.length; i++) {\n            let name = names[i], terms = groups[name];\n            if (nodeNames[name])\n                this.warn(`Group name '${name}' conflicts with a node of the same name`);\n            for (let j = i + 1; j < names.length; j++) {\n                let other = groups[names[j]];\n                if (terms.some(t => other.includes(t)) &&\n                    (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))\n                    this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);\n            }\n        }\n    }\n}\nconst MinSharedActions = 5;\nclass FinishStateContext {\n    constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {\n        this.tokenizers = tokenizers;\n        this.data = data;\n        this.stateArray = stateArray;\n        this.skipData = skipData;\n        this.skipInfo = skipInfo;\n        this.states = states;\n        this.builder = builder;\n        this.sharedActions = [];\n    }\n    findSharedActions(state) {\n        if (state.actions.length < MinSharedActions)\n            return null;\n        let found = null;\n        for (let shared of this.sharedActions) {\n            if ((!found || shared.actions.length > found.actions.length) &&\n                shared.actions.every(a => state.actions.some(b => b.eq(a))))\n                found = shared;\n        }\n        if (found)\n            return found;\n        let max = null, scratch = [];\n        for (let i = state.id + 1; i < this.states.length; i++) {\n            let other = this.states[i], fill = 0;\n            if (other.defaultReduce || other.actions.length < MinSharedActions)\n                continue;\n            for (let a of state.actions)\n                for (let b of other.actions)\n                    if (a.eq(b))\n                        scratch[fill++] = a;\n            if (fill >= MinSharedActions && (!max || max.length < fill)) {\n                max = scratch;\n                scratch = [];\n            }\n        }\n        if (!max)\n            return null;\n        let result = { actions: max, addr: this.storeActions(max, -1, null) };\n        this.sharedActions.push(result);\n        return result;\n    }\n    storeActions(actions, skipReduce, shared) {\n        if (skipReduce < 0 && shared && shared.actions.length == actions.length)\n            return shared.addr;\n        let data = [];\n        for (let action of actions) {\n            if (shared && shared.actions.some(a => a.eq(action)))\n                continue;\n            if (action instanceof Shift) {\n                data.push(action.term.id, action.target.id, 0);\n            }\n            else {\n                let code = reduceAction(action.rule, this.skipInfo);\n                if (code != skipReduce)\n                    data.push(action.term.id, code & 65535 /* Action.ValueMask */, code >> 16);\n            }\n        }\n        data.push(65535 /* Seq.End */);\n        if (skipReduce > -1)\n            data.push(2 /* Seq.Other */, skipReduce & 65535 /* Action.ValueMask */, skipReduce >> 16);\n        else if (shared)\n            data.push(1 /* Seq.Next */, shared.addr & 0xffff, shared.addr >> 16);\n        else\n            data.push(0 /* Seq.Done */);\n        return this.data.storeArray(data);\n    }\n    finish(state, isSkip, forcedReduce) {\n        let b = this.builder;\n        let skipID = b.skipRules.indexOf(state.skip);\n        let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;\n        let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;\n        let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;\n        let skipReduce = -1, shared = null;\n        if (defaultReduce == 0) {\n            if (isSkip)\n                for (const action of state.actions)\n                    if (action instanceof Reduce && action.term.eof)\n                        skipReduce = reduceAction(action.rule, this.skipInfo);\n            if (skipReduce < 0)\n                shared = this.findSharedActions(state);\n        }\n        if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length))\n            flags |= 2 /* StateFlag.Accepting */;\n        let external = [];\n        for (let i = 0; i < state.actions.length + skipTerms.length; i++) {\n            let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];\n            for (;;) {\n                let orig = b.tokenOrigins[term.name];\n                if (orig && orig.spec) {\n                    term = orig.spec;\n                    continue;\n                }\n                if (orig && (orig.external instanceof ExternalTokenSet))\n                    addToSet(external, orig.external);\n                break;\n            }\n        }\n        let tokenizerMask = 0;\n        for (let i = 0; i < this.tokenizers.length; i++) {\n            let tok = this.tokenizers[i];\n            if (external.includes(tok) || tok.groupID == state.tokenGroup)\n                tokenizerMask |= (1 << i);\n        }\n        let base = state.id * 6 /* ParseState.Size */;\n        this.stateArray[base + 0 /* ParseState.Flags */] = flags;\n        this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);\n        this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;\n        this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;\n        this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;\n        this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;\n    }\n}\nfunction addToProp(term, prop, value) {\n    let cur = term.props[prop];\n    if (!cur || cur.split(\" \").indexOf(value) < 0)\n        term.props[prop] = cur ? cur + \" \" + value : value;\n}\nfunction buildSpecializeTable(spec) {\n    let table = Object.create(null);\n    for (let { value, term, type } of spec) {\n        let code = type == \"specialize\" ? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;\n        table[value] = (term.id << 1) | code;\n    }\n    return table;\n}\nfunction reduceAction(rule, skipInfo, depth = rule.parts.length) {\n    return rule.name.id | 65536 /* Action.ReduceFlag */ |\n        (rule.isRepeatWrap && depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |\n        (skipInfo.some(i => i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |\n        (depth << 19 /* Action.ReduceDepthShift */);\n}\nfunction findArray(data, value) {\n    search: for (let i = 0;;) {\n        let next = data.indexOf(value[0], i);\n        if (next == -1 || next + value.length > data.length)\n            break;\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] != data[next + j]) {\n                i = next + 1;\n                continue search;\n            }\n        }\n        return next;\n    }\n    return -1;\n}\nfunction findSkipStates(table, startRules) {\n    let nonSkip = Object.create(null);\n    let work = [];\n    let add = (state) => {\n        if (!nonSkip[state.id]) {\n            nonSkip[state.id] = true;\n            work.push(state);\n        }\n    };\n    for (let state of table)\n        if (state.startRule && startRules.includes(state.startRule))\n            add(state);\n    for (let i = 0; i < work.length; i++) {\n        for (let a of work[i].actions)\n            if (a instanceof Shift)\n                add(a.target);\n        for (let a of work[i].goto)\n            add(a.target);\n    }\n    return (id) => !nonSkip[id];\n}\nclass DataBuilder {\n    constructor() {\n        this.data = [];\n    }\n    storeArray(data) {\n        let found = findArray(this.data, data);\n        if (found > -1)\n            return found;\n        let pos = this.data.length;\n        for (let num of data)\n            this.data.push(num);\n        return pos;\n    }\n    finish() {\n        return Uint16Array.from(this.data);\n    }\n}\n// The goto table maps a start state + a term to a new state, and is\n// used to determine the new state when reducing. Because this allows\n// more more efficient representation and access, unlike the action\n// tables, the goto table is organized by term, with groups of start\n// states that map to a given end state enumerated for each term.\n// Since many terms only have a single valid goto target, this makes\n// it cheaper to look those up.\n//\n// (Unfortunately, though the standard LR parsing mechanism never\n// looks up invalid goto states, the incremental parsing mechanism\n// needs accurate goto information for a state/term pair, so we do\n// need to store state ids even for terms that have only one target.)\n//\n// - First comes the amount of terms in the table\n//\n// - Then, for each term, the offset of the term's data\n//\n// - At these offsets, there's a record for each target state\n//\n//   - Such a record starts with the amount of start states that go to\n//     this target state, shifted one to the left, with the first bit\n//     only set if this is the last record for this term.\n//\n//   - Then follows the target state id\n//\n//   - And then the start state ids\nfunction computeGotoTable(states) {\n    let goto = {};\n    let maxTerm = 0;\n    for (let state of states) {\n        for (let entry of state.goto) {\n            maxTerm = Math.max(entry.term.id, maxTerm);\n            let set = goto[entry.term.id] || (goto[entry.term.id] = {});\n            (set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);\n        }\n    }\n    let data = new DataBuilder;\n    let index = [];\n    let offset = maxTerm + 2; // Offset of the data, taking index size into account\n    for (let term = 0; term <= maxTerm; term++) {\n        let entries = goto[term];\n        if (!entries) {\n            index.push(1);\n            continue;\n        }\n        let termTable = [];\n        let keys = Object.keys(entries);\n        for (let target of keys) {\n            let list = entries[target];\n            termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1));\n            termTable.push(+target);\n            for (let source of list)\n                termTable.push(source);\n        }\n        index.push(data.storeArray(termTable) + offset);\n    }\n    if (index.some(n => n > 0xffff))\n        throw new GenError(\"Goto table too large\");\n    return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);\n}\nclass TokenGroup {\n    constructor(tokens, groupID) {\n        this.tokens = tokens;\n        this.groupID = groupID;\n    }\n    create() { return this.groupID; }\n    createSource() { return String(this.groupID); }\n}\nfunction addToSet(set, value) {\n    if (!set.includes(value))\n        set.push(value);\n}\nfunction buildTokenMasks(groups) {\n    let masks = Object.create(null);\n    for (let group of groups) {\n        let groupMask = 1 << group.groupID;\n        for (let term of group.tokens) {\n            masks[term.id] = (masks[term.id] || 0) | groupMask;\n        }\n    }\n    return masks;\n}\nclass TokenArg {\n    constructor(name, expr, scope) {\n        this.name = name;\n        this.expr = expr;\n        this.scope = scope;\n    }\n}\nclass BuildingRule {\n    constructor(name, start, to, args) {\n        this.name = name;\n        this.start = start;\n        this.to = to;\n        this.args = args;\n    }\n}\nclass TokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.startState = new State$1;\n        this.built = [];\n        this.building = []; // Used for recursion check\n        this.byDialect = Object.create(null);\n        this.precedenceRelations = [];\n        this.rules = ast ? ast.rules : none;\n        for (let rule of this.rules)\n            b.unique(rule.id);\n    }\n    getToken(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return built.term;\n        let name = expr.id.name;\n        let rule = this.rules.find(r => r.id.name == name);\n        if (!rule)\n            return null;\n        let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, \"d\", name, expr.args, rule.params.length != expr.args.length ? none : rule.params);\n        let term = this.b.makeTerminal(expr.toString(), nodeName, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if ((term.nodeType || exported) && rule.params.length == 0) {\n            if (!term.nodeType)\n                term.preserve = true;\n            this.b.namedTerms[exported || name] = term;\n        }\n        this.buildRule(rule, expr, this.startState, new State$1([term]));\n        this.built.push(new BuiltRule(name, expr.args, term));\n        return term;\n    }\n    buildRule(rule, expr, from, to, args = none) {\n        let name = expr.id.name;\n        if (rule.params.length != expr.args.length)\n            this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);\n        let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args));\n        if (building) {\n            if (building.to == to) {\n                from.nullEdge(building.start);\n                return;\n            }\n            let lastIndex = this.building.length - 1;\n            while (this.building[lastIndex].name != name)\n                lastIndex--;\n            this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b => b.name).join(\" -> \")}`, expr.start);\n        }\n        this.b.used(rule.id.name);\n        let start = new State$1;\n        from.nullEdge(start);\n        this.building.push(new BuildingRule(name, start, to, expr.args));\n        this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) => new TokenArg(rule.params[i].name, e, args)));\n        this.building.pop();\n    }\n    build(expr, from, to, args) {\n        if (expr instanceof NameExpression) {\n            let name = expr.id.name, arg = args.find(a => a.name == name);\n            if (arg)\n                return this.build(arg.expr, from, to, arg.scope);\n            let rule;\n            for (let i = 0, lt = this.b.localTokens; i <= lt.length; i++) {\n                let set = i == lt.length ? this.b.tokens : lt[i];\n                rule = set.rules.find(r => r.id.name == name);\n            }\n            if (!rule)\n                return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);\n            this.buildRule(rule, expr, from, to, args);\n        }\n        else if (expr instanceof CharClass) {\n            for (let [a, b] of CharClasses[expr.type])\n                from.edge(a, b, to);\n        }\n        else if (expr instanceof ChoiceExpression) {\n            for (let choice of expr.exprs)\n                this.build(choice, from, to, args);\n        }\n        else if (isEmpty(expr)) {\n            from.nullEdge(to);\n        }\n        else if (expr instanceof SequenceExpression) {\n            let conflict = expr.markers.find(c => c.length > 0);\n            if (conflict)\n                this.b.raise(\"Conflict marker in token expression\", conflict[0].start);\n            for (let i = 0; i < expr.exprs.length; i++) {\n                let next = i == expr.exprs.length - 1 ? to : new State$1;\n                this.build(expr.exprs[i], from, next, args);\n                from = next;\n            }\n        }\n        else if (expr instanceof RepeatExpression) {\n            if (expr.kind == \"*\") {\n                let loop = new State$1;\n                from.nullEdge(loop);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else if (expr.kind == \"+\") {\n                let loop = new State$1;\n                this.build(expr.expr, from, loop, args);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else { // expr.kind == \"?\"\n                from.nullEdge(to);\n                this.build(expr.expr, from, to, args);\n            }\n        }\n        else if (expr instanceof SetExpression) {\n            for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)\n                rangeEdges(from, to, a, b);\n        }\n        else if (expr instanceof LiteralExpression) {\n            for (let i = 0; i < expr.value.length; i++) {\n                let ch = expr.value.charCodeAt(i);\n                let next = i == expr.value.length - 1 ? to : new State$1;\n                from.edge(ch, ch + 1, next);\n                from = next;\n            }\n        }\n        else if (expr instanceof AnyExpression) {\n            let mid = new State$1;\n            from.edge(0, 0xDC00, to);\n            from.edge(0xDC00, MAX_CHAR + 1, to);\n            from.edge(0xD800, 0xDC00, mid);\n            mid.edge(0xDC00, 0xE000, to);\n        }\n        else {\n            return this.b.raise(`Unrecognized expression type in token`, expr.start);\n        }\n    }\n    takePrecedences() {\n        let rel = this.precedenceRelations = [];\n        if (this.ast)\n            for (let group of this.ast.precedences) {\n                let prev = [];\n                for (let item of group.items) {\n                    let level = [];\n                    if (item instanceof NameExpression) {\n                        for (let built of this.built)\n                            if (item.args.length ? built.matches(item) : built.id == item.id.name)\n                                level.push(built.term);\n                    }\n                    else {\n                        let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id);\n                        if (found)\n                            level.push(found.term);\n                    }\n                    if (!level.length)\n                        this.b.warn(`Precedence specified for unknown token ${item}`, item.start);\n                    for (let term of level)\n                        addRel(rel, term, prev);\n                    prev = prev.concat(level);\n                }\n            }\n    }\n    precededBy(a, b) {\n        let found = this.precedenceRelations.find(r => r.term == a);\n        return found && found.after.includes(b);\n    }\n    buildPrecTable(softConflicts) {\n        let precTable = [], rel = this.precedenceRelations.slice();\n        // Add entries for soft-conflicting tokens that are in the\n        // precedence table, to make sure they'll appear in the right\n        // order and don't mess up the longer-wins default rule.\n        for (let { a, b, soft } of softConflicts)\n            if (soft) {\n                if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b))\n                    continue;\n                if (soft < 0)\n                    [a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)\n                addRel(rel, b, [a]);\n                addRel(rel, a, []);\n            }\n        add: while (rel.length) {\n            for (let i = 0; i < rel.length; i++) {\n                let record = rel[i];\n                if (record.after.every(t => precTable.includes(t.id))) {\n                    precTable.push(record.term.id);\n                    if (rel.length == 1)\n                        break add;\n                    rel[i] = rel.pop();\n                    continue add;\n                }\n            }\n            this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(\", \")}`);\n        }\n        return precTable;\n    }\n}\nclass MainTokenSet extends TokenSet {\n    constructor() {\n        super(...arguments);\n        this.explicitConflicts = [];\n    }\n    getLiteral(expr) {\n        let id = JSON.stringify(expr.value);\n        for (let built of this.built)\n            if (built.id == id)\n                return built.term;\n        let name = null, props = {}, dialect = null, exported = null;\n        let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null;\n        if (decl)\n            ({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, \"da\", expr.value));\n        let term = this.b.makeTerminal(id, name, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if (exported)\n            this.b.namedTerms[exported] = term;\n        this.build(expr, this.startState, new State$1([term]), none);\n        this.built.push(new BuiltRule(id, none, term));\n        return term;\n    }\n    takeConflicts() {\n        var _a;\n        let resolve = (expr) => {\n            if (expr instanceof NameExpression) {\n                for (let built of this.built)\n                    if (built.matches(expr))\n                        return built.term;\n            }\n            else {\n                let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id);\n                if (found)\n                    return found.term;\n            }\n            this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);\n            return null;\n        };\n        for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {\n            let a = resolve(c.a), b = resolve(c.b);\n            if (a && b) {\n                if (a.id < b.id)\n                    [a, b] = [b, a];\n                this.explicitConflicts.push({ a, b });\n            }\n        }\n    }\n    // Token groups are a mechanism for allowing conflicting (matching\n    // overlapping input, without an explicit precedence being given)\n    // tokens to exist in a grammar _if_ they don't occur in the same\n    // place (aren't used in the same states).\n    //\n    // States that use tokens that conflict will raise an error when any\n    // of the conflicting pairs of tokens both occur in that state.\n    // Otherwise, they are assigned a token group, which includes all\n    // the potentially-conflicting tokens they use. If there's already a\n    // group that doesn't have any conflicts with those tokens, that is\n    // reused, otherwise a new group is created.\n    //\n    // So each state has zero or one token groups, and each conflicting\n    // token may belong to one or more groups. Tokens get assigned a\n    // 16-bit bitmask with the groups they belong to set to 1 (all-1s\n    // for non-conflicting tokens). When tokenizing, that mask is\n    // compared to the current state's group (again using all-1s for\n    // group-less states) to determine whether a token is applicable for\n    // this state.\n    //\n    // Extended/specialized tokens are treated as their parent token for\n    // this purpose.\n    buildTokenGroups(states, skipInfo, startID) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        if (/\\btokens\\b/.test(verbose))\n            console.log(tokens.toString());\n        // If there is a precedence specified for the pair, the conflict is resolved\n        let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))\n            .filter(({ a, b }) => !this.precededBy(a, b) && !this.precededBy(b, a));\n        for (let { a, b } of this.explicitConflicts) {\n            if (!allConflicts.some(c => c.a == a && c.b == b))\n                allConflicts.push(new Conflict$1(a, b, 0, \"\", \"\"));\n        }\n        let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft);\n        let errors = [];\n        let groups = [];\n        for (let state of states) {\n            if (state.defaultReduce || state.tokenGroup > -1)\n                continue;\n            // Find potentially-conflicting terms (in terms) and the things\n            // they conflict with (in conflicts), and raise an error if\n            // there's a token conflict directly in this state.\n            let terms = [], incompatible = [];\n            let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;\n            for (let term of skip)\n                if (state.actions.some(a => a.term == term))\n                    this.b.raise(`Use of token ${term.name} conflicts with skip rule`);\n            let stateTerms = [];\n            for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {\n                let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length];\n                let orig = this.b.tokenOrigins[term.name];\n                if (orig && orig.spec)\n                    term = orig.spec;\n                else if (orig && orig.external)\n                    continue;\n                addToSet(stateTerms, term);\n            }\n            if (stateTerms.length == 0)\n                continue;\n            for (let term of stateTerms) {\n                for (let conflict of conflicts) {\n                    let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;\n                    if (!conflicting)\n                        continue;\n                    if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {\n                        let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : \"\"})` : \"\";\n                        errors.push({\n                            error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\\n` +\n                                `After: ${state.set[0].trail()}`,\n                            conflict\n                        });\n                    }\n                    addToSet(terms, term);\n                    addToSet(incompatible, conflicting);\n                }\n            }\n            let tokenGroup = null;\n            for (let group of groups) {\n                if (incompatible.some(term => group.tokens.includes(term)))\n                    continue;\n                for (let term of terms)\n                    addToSet(group.tokens, term);\n                tokenGroup = group;\n                break;\n            }\n            if (!tokenGroup) {\n                tokenGroup = new TokenGroup(terms, groups.length + startID);\n                groups.push(tokenGroup);\n            }\n            state.tokenGroup = tokenGroup.groupID;\n        }\n        if (errors.length)\n            this.b.raise(errors.map(e => e.error).join(\"\\n\\n\"));\n        if (groups.length + startID > 16)\n            this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);\n        let precTable = this.buildPrecTable(softConflicts);\n        return {\n            tokenGroups: groups,\n            tokenPrec: precTable,\n            tokenData: tokens.toArray(buildTokenMasks(groups), precTable)\n        };\n    }\n}\nclass LocalTokenSet extends TokenSet {\n    constructor(b, ast) {\n        super(b, ast);\n        this.fallback = null;\n        if (ast.fallback)\n            b.unique(ast.fallback.id);\n    }\n    getToken(expr) {\n        let term = null;\n        if (this.ast.fallback && this.ast.fallback.id.name == expr.id.name) {\n            if (expr.args.length)\n                this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);\n            if (!this.fallback) {\n                let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, \"\", expr.id.name, none, none);\n                let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);\n                if (term.nodeType || exported) {\n                    if (!term.nodeType)\n                        term.preserve = true;\n                    this.b.namedTerms[exported || expr.id.name] = term;\n                }\n                this.b.used(expr.id.name);\n            }\n            term = this.fallback;\n        }\n        else {\n            term = super.getToken(expr);\n        }\n        if (term && !this.b.tokenOrigins[term.name])\n            this.b.tokenOrigins[term.name] = { group: this };\n        return term;\n    }\n    buildLocalGroup(states, skipInfo, id) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        for (let { a, b, exampleA } of tokens.findConflicts(() => true)) {\n            if (!this.precededBy(a, b) && !this.precededBy(b, a))\n                this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);\n        }\n        for (let state of states) {\n            if (state.defaultReduce)\n                continue;\n            // See if this state uses any of the tokens in this group, and\n            // if so, make sure it *only* uses tokens from this group.\n            let usesThis = null;\n            let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];\n            for (let { term } of state.actions) {\n                let orig = this.b.tokenOrigins[term.name];\n                if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)\n                    usesThis = term;\n                else\n                    usesOther = term;\n            }\n            if (usesThis) {\n                if (usesOther)\n                    this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);\n                state.tokenGroup = id;\n            }\n        }\n        let precTable = this.buildPrecTable(none);\n        let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);\n        let precOffset = tokenData.length;\n        let fullData = new Uint16Array(tokenData.length + precTable.length + 1);\n        fullData.set(tokenData, 0);\n        fullData.set(precTable, precOffset);\n        fullData[fullData.length - 1] = 65535 /* Seq.End */;\n        return {\n            groupID: id,\n            create: () => new LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),\n            createSource: importName => `new ${importName(\"LocalTokenGroup\", \"@lezer/lr\")}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`\n        };\n    }\n}\nfunction checkTogether(states, b, skipInfo) {\n    let cache = Object.create(null);\n    function hasTerm(state, term) {\n        return state.actions.some(a => a.term == term) ||\n            skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);\n    }\n    return (a, b) => {\n        if (a.id < b.id)\n            [a, b] = [b, a];\n        let key = a.id | (b.id << 16), cached = cache[key];\n        if (cached != null)\n            return cached;\n        return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b));\n    };\n}\nfunction invertRanges(ranges) {\n    let pos = 0, result = [];\n    for (let [a, b] of ranges) {\n        if (a > pos)\n            result.push([pos, a]);\n        pos = b;\n    }\n    if (pos <= MAX_CODE)\n        result.push([pos, MAX_CODE + 1]);\n    return result;\n}\nconst ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;\nconst LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;\n// Create intermediate states for astral characters in a range, if\n// necessary, since the tokenizer acts on UTF16 characters\nfunction rangeEdges(from, to, low, hi) {\n    if (low < ASTRAL) {\n        if (low < GAP_START)\n            from.edge(low, Math.min(hi, GAP_START), to);\n        if (hi > GAP_END)\n            from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);\n        low = ASTRAL;\n    }\n    if (hi <= ASTRAL)\n        return;\n    let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);\n    let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);\n    let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);\n    if (lowA == hiA) { // Share the first char code\n        let hop = new State$1;\n        from.edge(lowA, lowA + 1, hop);\n        hop.edge(lowB, hiB + 1, to);\n    }\n    else {\n        let midStart = lowA, midEnd = hiA;\n        if (lowB > LOW_SURR_B) {\n            midStart++;\n            let hop = new State$1;\n            from.edge(lowA, lowA + 1, hop);\n            hop.edge(lowB, HIGH_SURR_B + 1, to);\n        }\n        if (hiB < HIGH_SURR_B) {\n            midEnd--;\n            let hop = new State$1;\n            from.edge(hiA, hiA + 1, hop);\n            hop.edge(LOW_SURR_B, hiB + 1, to);\n        }\n        if (midStart <= midEnd) {\n            let hop = new State$1;\n            from.edge(midStart, midEnd + 1, hop);\n            hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);\n        }\n    }\n}\nfunction isEmpty(expr) {\n    return expr instanceof SequenceExpression && expr.exprs.length == 0;\n}\nfunction gatherExtTokens(b, tokens) {\n    let result = Object.create(null);\n    for (let token of tokens) {\n        b.unique(token.id);\n        let { name, props, dialect } = b.nodeInfo(token.props, \"d\", token.id.name);\n        let term = b.makeTerminal(token.id.name, name, props);\n        if (dialect != null)\n            (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);\n        b.namedTerms[token.id.name] = result[token.id.name] = term;\n    }\n    return result;\n}\nfunction findExtToken(b, tokens, expr) {\n    let found = tokens[expr.id.name];\n    if (!found)\n        return null;\n    if (expr.args.length)\n        b.raise(\"External tokens cannot take arguments\", expr.args[0].start);\n    b.used(expr.id.name);\n    return found;\n}\nfunction addRel(rel, term, after) {\n    let found = rel.findIndex(r => r.term == term);\n    if (found < 0)\n        rel.push({ term, after });\n    else\n        rel[found] = { term, after: rel[found].after.concat(after) };\n}\nclass ExternalTokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n    create() {\n        return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);\n    }\n    createSource(importName) {\n        let { source, id: { name } } = this.ast;\n        return importName(name, source);\n    }\n}\nclass ExternalSpecializer {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.term = null;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n    }\n    finish() {\n        let terms = this.b.normalizeExpr(this.ast.token);\n        if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)\n            this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);\n        this.term = terms[0].terms[0];\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n}\nfunction inlineRules(rules, preserve) {\n    for (let pass = 0;; pass++) {\n        let inlinable = Object.create(null), found;\n        if (pass == 0)\n            for (let rule of rules) {\n                if (rule.name.inline && !inlinable[rule.name.name]) {\n                    let group = rules.filter(r => r.name == rule.name);\n                    if (group.some(r => r.parts.includes(rule.name)))\n                        continue;\n                    found = inlinable[rule.name.name] = group;\n                }\n            }\n        for (let i = 0; i < rules.length; i++) {\n            let rule = rules[i];\n            if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&\n                !preserve.includes(rule.name) &&\n                (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&\n                !rule.parts.some(p => !!inlinable[p.name]) &&\n                !rules.some((r, j) => j != i && r.name == rule.name))\n                found = inlinable[rule.name.name] = [rule];\n        }\n        if (!found)\n            return rules;\n        let newRules = [];\n        for (let rule of rules) {\n            if (inlinable[rule.name.name])\n                continue;\n            if (!rule.parts.some(p => !!inlinable[p.name])) {\n                newRules.push(rule);\n                continue;\n            }\n            function expand(at, conflicts, parts) {\n                if (at == rule.parts.length) {\n                    newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));\n                    return;\n                }\n                let next = rule.parts[at], replace = inlinable[next.name];\n                if (!replace) {\n                    expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));\n                    return;\n                }\n                for (let r of replace)\n                    expand(at + 1, conflicts.slice(0, conflicts.length - 1)\n                        .concat(conflicts[at].join(r.conflicts[0]))\n                        .concat(r.conflicts.slice(1, r.conflicts.length - 1))\n                        .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));\n            }\n            expand(0, [rule.conflicts[0]], []);\n        }\n        rules = newRules;\n    }\n}\nfunction mergeRules(rules) {\n    let merged = Object.create(null), found;\n    for (let i = 0; i < rules.length;) {\n        let groupStart = i;\n        let name = rules[i++].name;\n        while (i < rules.length && rules[i].name == name)\n            i++;\n        let size = i - groupStart;\n        if (name.interesting)\n            continue;\n        for (let j = i; j < rules.length;) {\n            let otherStart = j, otherName = rules[j++].name;\n            while (j < rules.length && rules[j].name == otherName)\n                j++;\n            if (j - otherStart != size || otherName.interesting)\n                continue;\n            let match = true;\n            for (let k = 0; k < size && match; k++) {\n                let a = rules[groupStart + k], b = rules[otherStart + k];\n                if (a.cmpNoName(b) != 0)\n                    match = false;\n            }\n            if (match)\n                found = merged[name.name] = otherName;\n        }\n    }\n    if (!found)\n        return rules;\n    let newRules = [];\n    for (let rule of rules)\n        if (!merged[rule.name.name]) {\n            newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :\n                new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip));\n        }\n    return newRules;\n}\nfunction simplifyRules(rules, preserve) {\n    return mergeRules(inlineRules(rules, preserve));\n}\n/**\nBuild an in-memory parser instance for a given grammar. This is\nmostly useful for testing. If your grammar uses external\ntokenizers, you'll have to provide the `externalTokenizer` option\nfor the returned parser to be able to parse anything.\n*/\nfunction buildParser(text, options = {}) {\n    let builder = new Builder(text, options), parser = builder.getParser();\n    parser.termTable = builder.termTable;\n    return parser;\n}\nconst KEYWORDS = [\"await\", \"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\",\n    \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"while\", \"with\",\n    \"null\", \"true\", \"false\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"new\", \"in\", \"this\",\n    \"const\", \"class\", \"extends\", \"export\", \"import\", \"super\", \"enum\", \"implements\", \"interface\",\n    \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"require\"];\n/**\nBuild the code that represents the parser tables for a given\ngrammar description. The `parser` property in the return value\nholds the main file that exports the `Parser` instance. The\n`terms` property holds a declaration file that defines constants\nfor all of the named terms in grammar, holding their ids as value.\nThis is useful when external code, such as a tokenizer, needs to\nbe able to use these ids. It is recommended to run a tree-shaking\nbundler when importing this file, since you usually only need a\nhandful of the many terms in your code.\n*/\nfunction buildParserFile(text, options = {}) {\n    return new Builder(text, options).getParserFile();\n}\nfunction ignored(name) {\n    let first = name[0];\n    return first == \"_\" || first.toUpperCase() != first;\n}\nfunction isExported(rule) {\n    return rule.props.some(p => p.at && p.name == \"export\");\n}\n\nexport { GenError, buildParser, buildParserFile };\n"],"names":["Node","constructor","start","this","GrammarDeclaration","rules","topRules","tokens","localTokens","context","externalTokens","externalSpecializers","externalPropSources","precedences","mainSkip","scopedSkip","dialects","externalProps","autoDelim","super","toString","Object","values","join","RuleDeclaration","id","props","params","expr","name","length","PrecDeclaration","items","TokenPrecDeclaration","TokenConflictDeclaration","a","b","TokenDeclaration","conflicts","literals","LocalTokenDeclaration","fallback","LiteralDeclaration","literal","ContextDeclaration","source","ExternalTokenDeclaration","ExternalSpecializeDeclaration","type","token","ExternalPropSourceDeclaration","ExternalPropDeclaration","externalID","Identifier","Expression","walk","f","eq","_other","prototype","prec","NameExpression","args","other","exprsEq","walkExprs","SpecializeExpression","content","Prop","eqProps","exprEq","InlineRuleExpression","rule","oRule","ChoiceExpression","exprs","map","e","maybeParens","SequenceExpression","markers","empty","every","m","i","om","x","ConflictMarker","RepeatExpression","kind","LiteralExpression","value","JSON","stringify","SetExpression","ranges","inverted","String","fromCodePoint","y","AnyExpression","result","slice","push","CharClasses","asciiLetter","asciiLowercase","asciiUppercase","digit","whitespace","eof","CharClass","at","v","test","p","PropPart","node","parent","GenError","Error","hasProps","_p","termHash","Term","flags","nodeName","hash","nodeType","top","repeated","terminal","error","interesting","preserve","inline","cmp","TermSet","terms","names","create","tops","term","makeTop","makeTerminal","makeNonTerminal","makeRepeat","uniqueName","cur","finish","filter","t","some","r","parts","includes","nodeTypes","nextID","minRepeatTerm","maxTerm","cmpSet","diff","none$3","Conflicts","precedence","ambigGroups","cut","none","Math","max","union","sort","ruleID","Rule","skip","cmpNoName","reduce","s","isRepeatWrap","sameReduce","Edge","from","to","target","charFor","n","fromCharCode","isEquivalent","partition","edges","eA","eB","applyMinimization","states","state","edge","stateID","State$1","State","accepting","nullEdge","compile","labeled","localID","startState","explore","newState","ids","out","transitions","separate","found","closure","MergedEdge","mergeEdges","merged","targets","byAccepting","group","split","newPartition","groups","minimize","seen","sameSet$1","findConflicts","occurTogether","cycleTerms","add","soft","aEdges","bEdges","find","c","Conflict$1","exampleFromEdges","reachable","j","es","hasCycle","orig","concat","work","table","Map","haveCycle","entry","get","set","next","pop","toArray","groupMasks","offsets","data","acceptEnd","stateMask","indexOf","pow","Uint16Array","mask","exampleA","exampleB","str","elts","elt","word","_","none$2","Input","string","fileName","end","lineInfo","pos","line","ch","message","msg","posInfo","info","raise","match","re","exec","readString","lastIndex","eat","unexpected","expect","val","parse","input","external","specialized","propSources","sawTop","parseRule","parseIdent","parseTokens","parseLocalTokens","parseExternalTokens","parseExternalProp","parseExternalSpecialize","parseExternalPropSource","first","parsePrecedence","parseBracedExpr","parseGrammar","named","parseProps","parseProp","parseExprChoice","SET_MARKER","parseExprInner","invert","unescaped","replace","code","codePointAt","addRange","charCodeAt","hasOwnProperty","cls","parseArgs","parseExprSuffix","endOfSequence","parseExprSequence","markerType","localStart","ms","left","tokenRules","parseTokenPrecedence","parseTokenConflict","parseExternalTokenSet","point","all","u1","u2","u3","single","unknown","parseInt","hashString","h","verbose","process","env","LOG","timing","time","label","t0","Date","now","console","log","toFixed","_label","Pos","ahead","ambigAhead","skipAhead","via","advance","cmpStr","eqSimple","splice","sameSet","trail","maxLen","reverse","addOrigins","conflictsAt","compareRepeatPrec","posB","termsAhead","after","cont","addTo","eqSet","Shift","Reduce","matches","mapping","mapped","hashPositions","ConflictContext","startRule","actions","actionPositions","goto","tokenGroup","defaultReduce","_actionsByTerm","g","addActionInner","positions","check","action","fullPos","actionFullPos","actionConflicts","addAction","conflict","conflictPos","termAfter","path","Set","hasMatch","inner","has","findConflictShiftSource","root","hist","unshift","repeat","p2","findConflictOrigin","Conflict","getGoto","hasSet","actionsByTerm","dThis","dOther","array","Core","applyCut","canMerge","byTerm","setB","setA","a1","a2","mergeStates","newStates","newID","Group","origin","member","members","samePosSet","none$1","digitToChar","encode","low","rest","encodeArray","Parts","ensureConflicts","otherConflicts","withConflicts","BuiltRule","matchesRepeat","Builder","text","options","tokenOrigins","built","ruleNames","namespaces","namedTerms","termTable","knownProps","dynamicRulePrecedences","definedGroups","astRules","currentSkip","ast","NP","NodeProp","prop","perNode","externalProp","d","MainTokenSet","LocalTokenSet","ext","ExternalTokenSet","decl","ExternalSpecializer","noSkip","newName","defineRule","scoped","findIndex","sc","isEmpty","unique","skipRules","normalizeExpr","used","nodeInfo","isExported","buildRule","warn","takePrecedences","takeConflicts","lt","defineGroup","checkGroups","base","prepareParser","groupStart","size","otherStart","otherName","k","newRules","mergeRules","pass","inlinable","expand","inlineRules","simplifyRules","termNames","startTerms","change","nt","startLen","part","computeFirstSets","skipInfo","startTokens","fullTable","statesBySetHash","cores","getState","core","coreHash","byHash","known","added","redo","addFor","existing","origIndex","forHash","startTerm","startSkip","filled","byTermPos","atEnd","index","replaced","count","buildFullAutomaton","grp","buildLocalGroup","tokenGroups","tokenPrec","tokenData","buildTokenGroups","didMerge","mergeIdentical","assignGroups","spill","groupIndex","idA","idB","collapseAutomaton","skipState","startRules","nonSkip","findSkipStates","buildSpecializeTable","tokStart","tokenizer","tokenizers","DataBuilder","skipData","storeArray","Uint32Array","forceReductions","computeForceReductions","finishCx","FinishStateContext","byDialect","dynamicPrecedences","precTable","nodeProps","skippedTypes","gatherNodeProps","stateData","computeGotoTable","nodeNames","repeatNodeCount","getParser","rawNodeProps","rawSpecialized","externalSpecializer","stack","extend","deserialize","version","externalPropSource","undefined","skippedNodes","tok","contextTracker","getParserFile","rawTokenizers","rawDialects","mod","moduleStyle","gen","head","imports","imported","defined","KEYWORDS","exportName","getName","prefix","importName","spec","src","varName","lrParser","createSource","serializePropValue","specHead","ts","typeScript","tableName","keys","key","parserStr","includeNames","parser","gatherNonSkippedNodes","forEach","notSkipped","rec","tag","reductions","candidates","gotoEdges","o","parents","length1Reductions","createsCycle","parentIntersection","reduceAction","setSize","done","substituteArgs","arg","substituteArgsInProps","substituteInValue","conflictsFor","here","marker","precs","item","choices","choice","resolve","getToken","normalizeRepeat","normalizeSequence","builder","complete","endConflicts","full","getLiteral","resolveSpecialization","dynamicPrec","explicitInline","exported","registerDynamicPrec","allow","defaultName","defaultProps","toUpperCase","ignored","dialect","finishProp","dialectID","builtin","delim","findDelimiters","addToProp","param","sp","findToken","lastToken","bracket","firstToken","_a","recur","getNamed","stateArray","sharedActions","findSharedActions","shared","scratch","fill","addr","storeActions","skipReduce","isSkip","forcedReduce","skipID","skipTable","skipTerms","addToSet","tokenizerMask","groupID","depth","search","findArray","num","offset","entries","list","TokenGroup","buildTokenMasks","masks","groupMask","TokenArg","scope","BuildingRule","TokenSet","building","precedenceRelations","build","loop","MAX_CODE","invertRanges","rangeEdges","mid","MAX_CHAR","rel","prev","level","addRel","precededBy","buildPrecTable","softConflicts","record","arguments","explicitConflicts","l","startID","allConflicts","cache","hasTerm","cached","checkTogether","errors","incompatible","stateTerms","conflicting","example","usesThis","usesOther","precOffset","fullData","ASTRAL","GAP_START","GAP_END","LOW_SURR_B","HIGH_SURR_B","hi","min","lowStr","hiStr","lowA","lowB","hiA","hiB","hop","midStart","midEnd","gatherExtTokens","findExtToken","externalTokenizer","buildParser"],"sourceRoot":""}