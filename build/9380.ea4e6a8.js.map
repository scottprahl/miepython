{"version":3,"file":"9380.ea4e6a8.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server/lib/service-worker-manager.js"],"sourcesContent":["import { Token } from '@lumino/coreutils';\nimport SW_URL from './service-worker?text';\n/**\n * The token for the ServiceWorker.\n */\nexport const IServiceWorkerManager = new Token('@jupyterlite/server:IServiceWorkerManager');\nexport const WORKER_NAME = `${SW_URL}`.split('/').slice(-1)[0];\n//# sourceMappingURL=tokens.js.map","import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { DriveContentsProcessor, } from '@jupyterlite/contents';\nimport { PromiseDelegate, UUID } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { WORKER_NAME } from './tokens';\n/**\n * The service-worker broadcast channel id\n */\nexport const SERVICE_WORKER_BROADCAST_CHANNEL_ID = '/sw-api.v1';\n/**\n * The version of the app\n */\nconst VERSION = PageConfig.getOption('appVersion');\n/**\n * Used to keep the service worker alive\n */\nconst SW_PING_ENDPOINT = '/api/service-worker-heartbeat';\n/**\n * A class that manages the ServiceWorker registration and communication,\n * used for accessing the file system.\n */\nexport class ServiceWorkerManager {\n    /**\n     * Construct a new ServiceWorkerManager.\n     */\n    constructor(options) {\n        var _a;\n        /**\n         * Handle a message received on the BroadcastChannel\n         *\n         * Message data is `any` because it can either be a drive message of type `TDriveReqiest<T>`\n         * or a stdin message of type `any` as ServiceWorkerManager passes it through to the\n         * stdinHandler without understanding or altering it.\n         */\n        this._onBroadcastMessage = async (event) => {\n            const { data, browsingContextId, pathname } = event.data;\n            if (browsingContextId !== this._browsingContextId) {\n                // Message is not meant for us\n                return;\n            }\n            if (pathname.includes('/api/stdin/')) {\n                this._onStdinMessage(pathname, data);\n            }\n            else {\n                this._onDriveMessage(data);\n            }\n        };\n        this._onDriveMessage = async (data) => {\n            const response = await this._driveContentsProcessor.processDriveRequest(data);\n            // pass the browsingContextId along so the Service Worker can identify the request\n            this._broadcastChannel.postMessage({\n                response,\n                browsingContextId: this._browsingContextId,\n            });\n        };\n        this._onStdinMessage = async (pathname, data) => {\n            // Expecting pathname of the form '<optional something>/api/stdin/<suffix>' from which\n            // suffix is used to identify which stdinHandler to call.\n            // `data: any` because ServiceWorkerManager accepts any data and passes it through\n            // to the stdinHandler without understanding or altering it.\n            const suffix = pathname.slice(pathname.lastIndexOf('/') + 1);\n            const stdinHandler = this._stdinHandlers.get(suffix);\n            if (stdinHandler !== undefined) {\n                const response = await stdinHandler(data);\n                this._broadcastChannel.postMessage({\n                    response,\n                    browsingContextId: this._browsingContextId,\n                });\n            }\n            else {\n                console.warn(`No stdin handler registered for '${pathname}'`);\n            }\n        };\n        this._registration = null;\n        this._registrationChanged = new Signal(this);\n        this._ready = new PromiseDelegate();\n        this._stdinHandlers = new Map();\n        const workerUrl = (_a = options.workerUrl) !== null && _a !== void 0 ? _a : URLExt.join(PageConfig.getBaseUrl(), WORKER_NAME);\n        const fullWorkerUrl = new URL(workerUrl, window.location.href);\n        const enableCache = PageConfig.getOption('enableServiceWorkerCache') || 'false';\n        fullWorkerUrl.searchParams.set('enableCache', enableCache);\n        // Initialize broadcast channel related properties\n        this._browsingContextId = UUID.uuid4();\n        this._contents = options.contents;\n        this._broadcastChannel = new BroadcastChannel(SERVICE_WORKER_BROADCAST_CHANNEL_ID);\n        this._broadcastChannel.addEventListener('message', this._onBroadcastMessage);\n        this._driveContentsProcessor = new DriveContentsProcessor({\n            contentsManager: this._contents,\n        });\n        void this._initialize(fullWorkerUrl.href).catch(console.warn);\n    }\n    /**\n     * A signal emitted when the registration changes.\n     */\n    get registrationChanged() {\n        return this._registrationChanged;\n    }\n    /**\n     * Whether the ServiceWorker is enabled or not.\n     */\n    get enabled() {\n        return this._registration !== null;\n    }\n    /**\n     * A unique id to identify the browsing context where the ServiceWorkerManager was instantiated.\n     */\n    get browsingContextId() {\n        return this._browsingContextId;\n    }\n    /**\n     * Whether the ServiceWorker is ready or not.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Register a handler for stdin requests received via ServiceWorker.\n     * @param pathnameSuffix URL pathname suffix to match such as \"kernel\" or \"terminal\".\n     * @param stdinHandler\n     */\n    registerStdinHandler(pathnameSuffix, stdinHandler) {\n        this._stdinHandlers.set(pathnameSuffix, stdinHandler);\n    }\n    /**\n     * Initialize the ServiceWorkerManager.\n     */\n    async _initialize(workerUrl) {\n        const { serviceWorker } = navigator;\n        let registration = null;\n        if (!serviceWorker) {\n            console.warn('ServiceWorkers not supported in this browser');\n            return;\n        }\n        else if (serviceWorker.controller) {\n            const scriptURL = serviceWorker.controller.scriptURL;\n            await this._unregisterOldServiceWorkers(scriptURL);\n            registration = (await serviceWorker.getRegistration(scriptURL)) || null;\n            // eslint-disable-next-line no-console\n            console.info('JupyterLite ServiceWorker was already registered');\n        }\n        if (!registration && serviceWorker) {\n            try {\n                // eslint-disable-next-line no-console\n                console.info('Registering new JupyterLite ServiceWorker', workerUrl);\n                registration = await serviceWorker.register(workerUrl);\n                // eslint-disable-next-line no-console\n                console.info('JupyterLite ServiceWorker was sucessfully registered');\n            }\n            catch (err) {\n                console.warn(err);\n                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);\n            }\n        }\n        this._setRegistration(registration);\n        if (!registration) {\n            this._ready.reject(void 0);\n        }\n        else {\n            this._ready.resolve(void 0);\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Unregister old service workers if the version has changed.\n     */\n    async _unregisterOldServiceWorkers(scriptURL) {\n        const versionKey = `${scriptURL}-version`;\n        // Check if we have an installed version. If we do, compare it to the current version\n        // and unregister all service workers if they are different.\n        const installedVersion = localStorage.getItem(versionKey);\n        if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {\n            // eslint-disable-next-line no-console\n            console.info('New version, unregistering existing service workers.');\n            const registrations = await navigator.serviceWorker.getRegistrations();\n            await Promise.all(registrations.map((registration) => registration.unregister()));\n            // eslint-disable-next-line no-console\n            console.info('All existing service workers have been unregistered.');\n        }\n        localStorage.setItem(versionKey, VERSION);\n    }\n    /**\n     * Ping the service worker to keep it alive.\n     */\n    async _pingServiceWorker() {\n        const response = await fetch(SW_PING_ENDPOINT);\n        const text = await response.text();\n        if (text === 'ok') {\n            setTimeout(this._pingServiceWorker, 20000);\n        }\n    }\n    /**\n     * Set the registration and emit a signal.\n     */\n    _setRegistration(registration) {\n        this._registration = registration;\n        this._registrationChanged.emit(this._registration);\n    }\n}\n//# sourceMappingURL=service-worker-manager.js.map"],"names":["IServiceWorkerManager","Token","WORKER_NAME","split","slice","SERVICE_WORKER_BROADCAST_CHANNEL_ID","VERSION","PageConfig","getOption","ServiceWorkerManager","constructor","options","_a","this","_onBroadcastMessage","async","event","data","browsingContextId","pathname","_browsingContextId","includes","_onStdinMessage","_onDriveMessage","response","_driveContentsProcessor","processDriveRequest","_broadcastChannel","postMessage","suffix","lastIndexOf","stdinHandler","_stdinHandlers","get","undefined","console","warn","_registration","_registrationChanged","Signal","_ready","PromiseDelegate","Map","workerUrl","URLExt","join","getBaseUrl","fullWorkerUrl","URL","window","location","href","enableCache","searchParams","set","UUID","uuid4","_contents","contents","BroadcastChannel","addEventListener","DriveContentsProcessor","contentsManager","_initialize","catch","registrationChanged","enabled","ready","promise","registerStdinHandler","pathnameSuffix","serviceWorker","navigator","registration","controller","scriptURL","_unregisterOldServiceWorkers","getRegistration","info","register","err","_setRegistration","resolve","setTimeout","_pingServiceWorker","reject","versionKey","installedVersion","localStorage","getItem","registrations","getRegistrations","Promise","all","map","unregister","setItem","fetch","text","emit"],"sourceRoot":""}